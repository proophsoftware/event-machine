[{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1","title":"About Event Machine","content":"prooph software Event Machine takes away all the boring, time consuming parts of event sourcing to speed up development of event sourced applications and increase the fun. It can be used for prototypes as well as full featured applications."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1-1","title":"Origin","content":"Event Machine was originally designed as a \"workshop framework\" for CQRS and Event Sourcing and is inspired by the Dreyfus model."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1-1-1","title":"Beginner friendly","content":" The Dreyfus model distinguishes five levels of competence, from novice to mastery. At the absolute beginner level people execute tasks based on \u00e2\u0080\u009crigid adherence to taught rules or plans\u00e2\u0080\u009d. Beginners need recipes. They don\u00e2\u0080\u0099t need a list of parts, or a dozen different ways to do the same thing. Instead what works are step by step instructions that they can internalize. As they practice them over time they learn the reasoning behind them, and learn to deviate from them and improvise, but they first need to feel like they\u00e2\u0080\u0099re doing something. (source: https:\/\/lambdaisland.com\/blog\/25-05-2017-simple-and-happy-is-clojure-dying-and-what-has-ruby-got-to-do-with-it)"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1-1-2","title":"Rapid Application Development","content":"It turned out that Event Machine is not only a very good CQRS and Event Sourcing learning framework but that the same concept can be used for rapid application development (RAD). RAD frameworks focus on developer happiness and coding speed. Both can be achieved by using conventions, which allow the framework to do a lot of work \"under the hood\" Developers can focus on the important part: developing the application."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1-2","title":"Event Machine Flavours","content":"Event Machine Flavours make it possible to turn a rapidly developed prototype into a rock solid application. You can switch from the default PrototypingFlavour to either the FunctionalFlavour or OopFlavour. Finally, you can implement your own Flavour to build your very own CQRS \/ ES framework.Learn More"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/about.html#1-1-3","title":"Powered By","content":"Event Machine is maintained by the prooph software team. Prooph software offers commercial support and workshops for Event Machine as well as for the prooph components.If you are interested please get in touch"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/pros_and_cons.html#1-2-1","title":"Pros","content":" Based on the rich features provided by prooph components Ready-to-use skeleton Less code to write Guided event sourcing extension points to inject custom logic Audit log from day one (no data loss) Replay functionality Projections based on domain events PSR friendly http message box OpenAPI v3 Swagger integration Message flow analyzer (work in progress) Event store HTTP API (work in progress) "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/pros_and_cons.html#1-2-2","title":"Cons","content":" Not suitable for monolithic architectures "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/pros_and_cons.html#1-2-2-1","title":"You may want to use Event Machine if:","content":" Your project is in an early stage and you need to try out different ideas or deliver features very fast You want to establish a Microservices architecture rather than building a monolithic system You want to automate business processes You have to develop a workflow-oriented service You're new to the concepts of CQRS and Event Sourcing and want to learn them You want to try CQRS and Event Sourcing in a side project without spending too much time with the theory "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/intro\/pros_and_cons.html#1-2-3","title":"Conclusion","content":"Try the tutorial and build a prototype with Event Machine! (If you are interested, you can contact us for a guided workshop)"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1","title":"Introduction","content":"Event Machine is a rapid application development (RAD) framework so let us jump directly into the practical part of the tutorial. Event Machine basic concepts will be explained throughout the tutorial. Once finished, you should be able to start with your own project. The API docs will help you along the way."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-1","title":"Workshops And Commercial Support","content":"Our team can help you to take the first steps and work out a solid foundation for your project based on the power and speed offered by Event Machine. If you're interested in workshops or commercial support, get in touch."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-2","title":"Tutorial Domain","content":"We will build a backend for a small application where you can register buildings and then check in and check out users in the buildings. The backend will expose a messagebox endpoint that excepts commands and queries. Each time a user is checked in or checked out we get a notification via a websocket connection.Credits: The tutorial domain is the same as the one used by Marco Pivetta in his CQRS and Event Sourcing Workshops."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3","title":"Application set up","content":"Please make sure you have Docker and Docker Compose installed.Note: Docker is THE ONLY supported set up at the moment. If you don't want to install docker you need PHP 7.1+ and Postgres 9.4+."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3-1","title":"Clone Event Machine Skeleton","content":"Change into your working directory and use composer to create a new project based on the event machine skeleton using prooph-em-buildings as project name.$ docker run --rm -it -v $(pwd):\/app prooph\/composer:7.1 create-project proophsoftware\/event-machine-skeleton prooph-em-buildings Change into the newly created project dir prooph-em-buildings, start the docker containers and run the set up script for the event store.$ cd prooph-em-buildings $ sudo chown -R $(id -u -n):$(id -g -n) . $ docker-compose up -d $ docker-compose run php php scripts\/create_event_stream.php The last command should output done. otherwise it will throw an exception."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3-2-1","title":"Database","content":"Verify database set up by connecting to the Postgres database using:host: localhost port: 5432 dbname: event_machine user: postgres pwd: Note: Credentials are defined in app.env and can be changed there.You should see three tables: event_streams, projections and _&lt;sha1&gt;. The latter is a table created by prooph\/event-store. It will contain all domain events."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3-2-2","title":"Webserver","content":"Head over to http:\/\/localhost:8080 to check if the containers are up and running. You should see a \"It works\" message."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/intro.html#2-1-3-2-3","title":"Swagger UI","content":"By default Event Machine exposes commands (we will learn more about them in a minute), events and queries via a message box endpoint. We can use Swagger UI to interact with the backend.The Event Machine skeleton ships with a ready to use Swagger UI. Open http:\/\/localhost:8080\/swagger\/index.html in your browser and try the built-in HealthCheck query.You should get a JSON response similar to that one:{ \"system\": true } If everything works correctly we are ready to implement our first use case: Add a buildingNote: If something is not working as expected (now or later in the tutorial) please check the trouble shooting section of the event-machine-skeleton README first."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partI.html#2-2","title":"Part I - Add A Building","content":"We're going to add the first action to our buildings application. In a CQRS system, such as Event Machine, operations and processes are triggered by messages. Those messages can have three different types and define the API of the application. In the first part of the tutorial we learn the first message type: command."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partI.html#2-2-1","title":"API","content":"The Event Machine skeleton includes an API folder (src\/Api) that contains a predefined set of EventMachineDescription classes. We will look at these descriptions step by step and start with src\/Api\/Command.php:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Command implements EventMachineDescription { \/** * Define command names using constants * * @example * * const REGISTER_USER = 'RegisterUser'; *\/ \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/\/Describe commands of the service and corresponding payload schema (used for input validation) } } The Command description is used to group all commands of our application into one file and add semantic meaning to our code. Replace the comment with a real constant const ADD_BUILDING = 'AddBuilding'; and register the command in the describe method.&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const ADD_BUILDING = 'AddBuilding'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ 'buildingId' =&gt; JsonSchema::uuid(), 'name' =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } Event Machine uses JSON Schema to describe messages. The advantage of JSON schema is that we can configure validation rules for our messages. Whenever Event Machine receives a message (command, event or query) it uses the defined JSON Schema for that message to validate the input. We configure it once and Event Machine takes care of the rest.Note: The skeleton defines the namespace App in composer.json and maps it to the src directory. You can change that for your own project, but you need to change the namespaces of the classes\/interfaces shipped with the skeleton which are located in the src directory (just a few helpers)"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partI.html#2-2-2","title":"Descriptions","content":"Event Machine Descriptions are very important. They are called at \"compile time\" and used to configure Event Machine. Later in the tutorial we learn more about using Event Machine in production. In production mode the descriptions are only called once and cached to speed up bootstrapping."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partI.html#2-2-3","title":"Swagger Integration","content":"Switch to the Swagger UI and reload the schema (press explore button). Swagger UI should show a new command called AddBuilding in the commands section.Click on the \"Try it out\" button and execute the AddBuilding command with the this request body:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"Acme Headquarters\" } } { \"error\": { \"message\": \"CommandBus was not able to identify a CommandHandler for command AddBuilding\", \"details\": \"...\" } } Our command cannot be handled because a command handler is missing. In Event Machine commands can be routed directly to Aggregates. In part II of the the tutorial you'll learn more about pure aggregates.Sum up: Event Machine Descriptions allow you to easily describe the API of your application using messages. The messages get a unique name and their payload is described with JSON Schema which allow us to add validation rules. The messages and their schema are translated to an OpenAPI v3 Schema and we can use Swagger UI to interact with the backend service."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partII.html#2-3","title":"Part II - The Building Aggregate","content":"In Event Machine we can take a short cut and skip command handlers. This is possible because Aggregates in Event Machine are stateless and pure. This means that they don't have internal state and also no dependencies.Simply put: they are just functionsEvent Machine can take over the boilerplate and we, as developers, can focus on the business logic. I'll explain in greater detail later, but first we want to see a pure aggregate function in action.Note: If you've worked with a CQRS framework before it is maybe confusing because normally a command is handled by a command handler (comparable to an application service that handles a domain action) and the command handler would load a business entity or \"DDD\" aggregate from a repository. We still use the aggregate concept but make use of a functional programming approach. It keeps the domain model lean and testable and allows some nice optimizations for a RAD infrastructure.Let's add the first aggregate called Building in a new Model folder:&lt;?php declare(strict_types=1); namespace App\\Model; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { \/\/yield domain events } } As you can see the Building class uses static methods. It does not extend from a base class and has no dependencies. We could also use plain PHP functions instead but unfortunately PHP does not provide function autoloading (yet), so we stick to static methods and group all methods of an aggregate in a class.Building::add() receives AddBuilding messages (of type command) and should perform the business logic needed to add a new building to our application. But instead of adding a new building directly we're ask to yield a domain event.A neat feature called Flavours allows you to choose between different programming styles. Throughout the tutorial we use the PrototypingFlavour. Two bonus parts at the end of the tutorial introduce the FunctionalFlavour and OopFlavour."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partII.html#2-3-1","title":"Domain Events","content":"Domain events are the second message type used by Event Machine. The domain model is event sourced, meaning it records all state changes in a series of domain events. These domain events are yielded by aggregate methods and stored in an event store managed by Event Machine. The series of events can then be used to calculate the current state of an aggregate. We will see that in action in a later part of the tutorial and get a better understanding of the technique when we add more use cases to the application.For now let's add the first domain event in src\/Api\/Event:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ 'buildingId' =&gt; JsonSchema::uuid(), 'name' =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } It looks similar to the AddBuilding command but uses a past tense name. That is a very important difference. Commands tell the application what it should do and events represent facts that have happened."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partII.html#2-3-2","title":"Yielding Events","content":"Aggregate methods can yield null, one domain event or multiple domain events depending on the result of the executed business logic. If an aggregate method yields null it indicates that no important fact happened and no event needs to be recorded. In many cases an aggregate method will yield one event which is the fact caused by the corresponding command. But there is no one-to-one connection between commands and events. In some cases more than one event is needed to communicate important facts or an error event is yielded instead of the expected event (we'll see that later).For the first use case we simply yield a BuildingAdded domain event when Building::add() is called with a AddBuilding command.&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } } The special array syntax for yielding events is a short cut used by Event Machine. It creates the event based on given event name and payload and stores it in the event stream."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partII.html#2-3-3","title":"Aggregate Description","content":"If we switch back to the Swagger UI and send the AddBuilding command again, Event Machine still complains about a missing command handler. We need to tell Event Machine about our new aggregate and that it is responsible for handling AddBuilding commands. We can do this in another Event Machine Description in src\/Api\/Aggregate.&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy('buildingId') -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED); } } The connection between command and aggregate is described in a very verbose and readable way. Our IDE can suggest the describing methods of Event Machine's fluent interface and it is easy to remember each step. process tells Event Machine that the following description is for the given command name. withNew\/withExisting tells Event Machine which aggregate handles the command and if the aggregate exists already or a new one should be created. identifiedBy tells Event Machine which message payload property should be used to identify the responsible aggregate. Every command sent to the aggregate and every event yielded by the aggregate should contain this property handle takes a callable argument which is the aggregate method responsible for handling the command defined in process. We use the callable array syntax of PHP which can be analyzed by modern IDEs like PHPStorm for auto completion and refactorings. recordThat tells Event Machine which event is yielded by the aggregate's command handling method. If we try again to send AddBuilding we get a new error:{ \"error\": { \"message\": \"No apply function specified for event: BuildingAdded\", \"details\": \"...\" } } Command handling works now but an apply function is missing. In part III of the tutorial you'll learn how to add such a function and why it is needed."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIII.html#2-4","title":"Part III - Aggregate State","content":"In part II we took a closer look at pure aggregate functions (implemented as static class methods in PHP because of missing function autoloading capabilities). Pure functions don't have side effects and are stateless. This makes them easy to test and understand. But an aggregate without state? How can an aggregate protect invariants (its main purpose) without state?The aggregate needs a way \"to look back\". It needs to know what happened in the past according to its own lifecycle. Without its current state and without information about past changes the aggregate could only execute business logic and enforce business rules based on the given information of the current command passed to a handling function. In most cases this is not enough.The functional programming solution to that problem is to pass the current state (which is computed from the past events recorded by the aggregate) to each command handling function (except the one handling the first command). This means that aggregate behaviour (command handling functions) and aggregate state (a data structure of a certain type) are two different things and separated from each other. How this is implemented in Event Machine is shown in this part of the tutorial."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIII.html#2-4-1","title":"Applying Domain Events","content":"Aggregate state is computed by iterating over all recorded domain events of the aggregate history starting with the oldest event. Event Machine does not provide a generic way to compute current state, instead the aggregate should have an apply function for each recorded event. Those apply functions are often prefixed with when followed by the event name.Let's add such a function for our BuildingAdded domain event.&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { \/\/@TODO: Return new state for the aggregate } } BuildingAdded communicates that a new lifecycle of a building was started (new building was added to our system), so the Building::whenBuilidngAdded() function has to return a new state object and does not receive a current state object as an argument (next when* function will receive one!).But what does the State object look like? Well, you can use whatever you want. Event Machine does not care about a particular implementation (see docs for details). However, Event Machine ships with a default implementation of an ImmutableRecord. We use that implementation in the tutorial, but it is your choice if you want to use it in your application, too.Create a State class in src\/Model\/Building (new directory):&lt;?php declare(strict_types=1); namespace App\\Model\\Building; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class State implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var string *\/ private $buildingId; \/** * @var string *\/ private $name; \/** * @return string *\/ public function buildingId(): string { return $this-&gt;buildingId; } \/** * @return string *\/ public function name(): string { return $this-&gt;name; } } Note: You can use PHPStorm to generate the Getter-Methods. You only have to write the private properties and add the doc blocks with @var type hints. Then use PHPStorm's ability to add the Getter-Methods (ALT+EINF). By default PHPStorm sets a get* prefix for each method. However, immutable records don't have setter methods and don't work with the get* prefix. Just change the template in your PHPStorm config: Settings -&gt; Editor -&gt; File and Code Templates -&gt; PHP Getter Method to:\/** * @return ${TYPE_HINT} *\/ public ${STATIC} function ${FIELD_NAME}()#if(${RETURN_TYPE}): ${RETURN_TYPE}#else#end { #if (${STATIC} == \"static\") return self::$${FIELD_NAME}; #else return $this-&gt;${FIELD_NAME}; #end } Now we can return a new Building\\State from Building::whenBuilidngAdded().&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } } Finally, we have to tell Event Machine about that apply function to complete the AddBuilding use case description. In src\/Api\/Aggregate:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy('buildingId') -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED) \/\/Map recorded event to apply function -&gt;apply([Building::class, 'whenBuildingAdded']); } } We're done with the write model for the first use case. If you send the AddBuilding command again using Swagger UI:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"Acme Headquarters\" } } ... you should receive a [202] command accepted responseEvent Machine emphasizes a CQRS and Event Sourcing architecture. For commands this means that no data is returned. The write model has received and processed the command AddBuilding successfully but we don't know what the new application state looks like. We will use a query, which is the third message type, to get this data. Head over to tutorial part IV to learn more about queries and application state management using projections."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5","title":"Part IV - Projections and Queries","content":"In part III of the tutorial we successfully implemented the first write model use case: Add a new building. Connect to the Postgres database and check the event stream table _4228e4a00331b5d5e751db0481828e22a2c3c8ef. The table should contain the first domain event yielded by the Building aggregate and recorded by event machine. no event_id event_name payload metadata created_at 1 bce42506-... BuildingAdded {\"buildingId\":\"9ee8d8a8-...\",\"name\":\"Acme Headquarters\"} {\"_aggregate_id\": \"9ee8d8a8-...\", \"_causation_id\": \"e482f5b8-...\", \"_aggregate_type\": \"Building\", \"_causation_name\": \"AddBuilding\", \"_aggregate_version\": 1} 2018-02-14 22:09:32.039848 If you're wondering why the event stream table has a sha1 hashed name this is because by default prooph\/event-store uses that naming strategy to avoid database vendor specific character constraints. You can however configure a different naming strategy if you don't like it.The write model only needs an event stream to store information but the read side has a hard time querying it. As long as we only have a few events in the stream queries are simple and fast. But over time this table will grow and contain many different events. To stay flexible we need to separate the write side from the read side. And this is done using so called projections."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5-1","title":"Registering Projections","content":"Projections in Event Machine make use of the projection feature shipped with prooph\/event-store. An important difference is that by default Event Machine uses a single long-running PHP process to manage those projections. This way processing order of events is always the same (FIFO). A disadvantage is that projections are slower because of the sequential processing.But don't worry: If projections become a bottleneck you can simply switch to plain prooph\/event-store projections and run them in parallel. The recommendation is to switch to that approach only if it is really needed. Deploying and coordinating multiple projection processes requires a good (project specific) strategy and tools.Ok enough theory. Let's get back to the beauty and simplicity of Event Machine. You can use a shortcut if aggregate state should be available as a read model. You only need one of the available EventMachine\\Persistence\\DocumentStore implementations. By default the skeleton uses proophsoftware\/postgres-document-store but you can also use proophsoftware\/mongo-document-store or implement your own. See Event Machine docs for details.We only need to register an aggregate projection in src\/Api\/Projection:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\Persistence\\Stream; class Projection implements EventMachineDescription { \/** * You can register aggregate and custom projections in event machine * * For custom projection you should define a unique projection name using a constant * * const USER_FRIENDS = 'UserFriends'; *\/ \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;watch(Stream::ofWriteModel()) -&gt;withAggregateProjection(Aggregate::BUILDING); } } That's it. If you look into the Postgres DB you should see a new table called em_ds_building_projection_0_1_0. And the table should contain one row with two columns id and doc with id being the buildingId and doc being the JSON representation of the Building\\State.Note: If you cannot see the table please check the troubleshooting section of event-machine-skeleton README.You can learn more about projections in the docs. For now it is enough to know how to register them. Let's complete the picture and query the projection table using Swagger UI."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5-2","title":"Query, Resolver and Return Type","content":"We already know that Event Machine uses JSON Schema to describe message types and define validation rules. For queries we can also register return types in Event Machine and those return types will appear in the Model section of the Swagger UI.Registering types is done in src\/Api\/Type:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\ObjectType; class Type implements EventMachineDescription { const HEALTH_CHECK = 'HealthCheck'; private static function healthCheck(): ObjectType { return JsonSchema::object([ 'system' =&gt; JsonSchema::boolean() ]); } \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/\/Register the HealthCheck type returned by @see \\App\\Api\\Query::HEALTH_CHECK $eventMachine-&gt;registerType(self::HEALTH_CHECK, self::healthCheck()); $eventMachine-&gt;registerType(Aggregate::BUILDING, Building\\State::__schema()); } } As you can see the HealthCheck type used by the HealthCheck query is already registered here. We simply add Building\\State as the second type and use the aggregate type as name for the building type.Note: Types are described using JSON Schema. Building\\State implements ImmutableRecord and therefore provides the method ImmutableRecord::__schema (provided by ImmutableRecordLogic trait) which returns a JSON Schema object.Note: Using aggregate state as return type for queries couples the write model with the read model. However, you can replace the return type definition at any time. So we can use the short cut in an early stage and switch to a decoupled version later.Next step is to register the query in src\/Api\/Query:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; public static function describe(EventMachine $eventMachine): void { \/\/Default query: can be used to check if service is up and running $eventMachine-&gt;registerQuery(self::HEALTH_CHECK) \/\/&lt;-- Payload schema is optional for queries -&gt;resolveWith(HealthCheckResolver::class) \/\/&lt;-- Service id (usually FQCN) to get resolver from DI container -&gt;setReturnType(Schema::healthCheck()); \/\/&lt;-- Type returned by resolver $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ 'buildingId' =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(\/* ??? *\/) -&gt;setReturnType(JsonSchema::typeRef(Aggregate::BUILDING)); } } Queries are named like the \"things\" they return. This results in a clean and easy to use messagebox schema.Please note that the return type is a reference: JsonSchema::typeRef().Last but not least, the query needs to be handled by a so-called finder (prooph term).When the query is sent to the messagebox endpoint it is translated into a query message that is passed on to prooph's query bus. The query message is validated against the schema defined during query registration $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object(...)).Our first query has a required argument, buildingId, which should be a valid Uuid. An invalid uuid will fail when the query is parsed into a Event Machine message.Long story short, we need a finder, as described in the prooph docs: QueryBus: much the same as the command bus but the message handler is invoked with the query message and a React\\Promise\\Deferred that needs to be resolved by the message handler aka finder. Create a new class called BuildingFinder in a new directory Finder in src\/Infrastructure.&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use Prooph\\EventMachine\\Messaging\\Message; use React\\Promise\\Deferred; final class BuildingFinder { public function __invoke(Message $buildingQuery, Deferred $deferred): void { \/\/@TODO: resolve $deferred } } This is an invokable finder, as described in the prooph docs. It receives the query message as the first argument and a React\\Promise\\Deferred as the second argument. prooph's query bus can be used in an async, non-blocking I\/O runtime as well as a normal, blocking runtime, so the finder must resolve the deferred object instead of returning a result. We work with the Promise and Deferred objects provided by the ReactPHP library (unfortunately, we have no PSR for promises yet). Event Machine takes care of resolving promises returned by prooph's query bus.Finders or resolvers are async by default, due to prooph's QueryBus used under the hood. However, a finder can implement the marker interface Prooph\\EventMachine\\Querying\\SyncResolver to change method signature and return a result instead of resolving a deferred object. Check the docs for details.The finder needs to query the read model. While looking at projections we briefly discussed Event Machine's DocumentStore API. The finder can use it to access documents organized in collections. Let's see how that works.&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use React\\Promise\\Deferred; final class BuildingFinder { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $collectionName; public function __construct(string $collectionName, DocumentStore $documentStore) { $this-&gt;collectionName = $collectionName; $this-&gt;documentStore = $documentStore; } public function __invoke(Message $buildingQuery, Deferred $deferred): void { $buildingId = $buildingQuery-&gt;get('buildingId'); $buildingDoc = $this-&gt;documentStore-&gt;getDoc($this-&gt;collectionName, $buildingId); if(!$buildingDoc) { $deferred-&gt;reject(new \\RuntimeException('Building not found', 404)); return; } $deferred-&gt;resolve($buildingDoc); } } The implementation is self explanatory, but a few notes should be made.Every Event Machine message has a get and a getOrDefault method which are both short cuts to access keys of the message payload. The difference between the two is obvious. If the payload key is NOT set and you use get the message will throw an exception. If the payload key is NOT set and you use getOrDefault you get back the default passed as the second argument.The second note is about the collection name. It is injected at runtime rather than defined as a hardcoded string or constant. Do you remember the read model table name em_ds_building_projection_0_1_0? First of all, this is also a default naming strategy and can be changed. However, the interesting part here is the version number at the end of the name. This is the application version which you can pass to EventMachine::boostrap() (see docs for details). When deploying a new application version it is possible to rebuild all projection tables using the new version while the old projection tables remain active until load balancers are switched (Blue Green Deployment).Finally, we need to configure Event Machine's DI container to inject the dependencies into our new finder."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5-3","title":"PSR-11 Container","content":"Event Machine can use any PSR-11 compatible container. By default it uses a very simple implementation included in the Event Machine package. The DI container is inspired by bitExpert\/disco but removes the need for annotations. Dependencies are managed in a single ServiceFactory class which is located in src\/Service.Just add the following method to the ServiceFactory:&lt;?php namespace App\\Service; \/\/New use statements use App\\Api\\Aggregate; use App\\Infrastructure\\Finder\\BuildingFinder; use Prooph\\EventMachine\\Projecting\\AggregateProjector; \/\/Other use statements use ... final class ServiceFactory { \/* ... *\/ public function setContainer(ContainerInterface $container): void { $this-&gt;container = $container; } \/\/Finders public function buildingFinder(): BuildingFinder \/\/&lt;-- Return type is used as service id { \/\/Service is treated as a singleton, DI returns the same instance on subsequent gets return $this-&gt;makeSingleton(BuildingFinder::class \/*&lt;-- again service id *\/, function () { return new BuildingFinder( \/\/We can use the AggregateProjector to generate correct collection name AggregateProjector::aggregateCollectionName( $this-&gt;eventMachine()-&gt;appVersion(), \/\/&lt;-- Inside a closure we still have access to other methods Aggregate::BUILDING \/\/ of the ServiceFactory, like the getter for Event Machine itself ), $this-&gt;documentStore() \/\/ or the document store ); }); } \/* ... *\/ } And use BuildingFinder::class as the finder service id when registering the query in src\/Api\/Query:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\BuildingFinder; \/\/&lt;-- New use statement use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ 'buildingId' =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(BuildingFinder::class) \/\/&lt;-- Finder service id -&gt;setReturnType(JsonSchema::typeRef(Aggregate::BUILDING)); } } Ok! We should be able to query buildings by buildingId now. Switch to Swagger and reload the schema (press the \"explore\" button). The Documentation Explorer should show a new Query: Building. If we send that query with the buildingId used in AddBuilding:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } } We get back:{ \"name\": \"Acme Headquarters\", \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } Awesome, isn't it?"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partIV.html#2-5-4","title":"Optional Query Arguments","content":"Finders can also handle multiple queries. This is useful when multiple queries can be resolved by accessing the same read model collection. A second query for the BuildingFinder would be a query that lists all buildings or a subset filtered by name.Add the query to src\/Api\/Query:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\BuildingFinder; use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; const BUILDINGS = 'Buildings'; \/\/&lt;-- New query, note the plural public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ 'buildingId' =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(JsonSchema::typeRef(Aggregate::BUILDING)); \/\/New query $eventMachine-&gt;registerQuery( self::BUILDINGS, JsonSchema::object( [], \/\/No required arguments for this query \/\/Optional argument name, is a nullable string ['name' =&gt; JsonSchema::nullOr(JsonSchema::string()-&gt;withMinLength(1))] ) ) \/\/Resolve query with same finder ... -&gt;resolveWith(BuildingFinder::class) \/\/... but return an array of Building type -&gt;setReturnType(JsonSchema::array( JsonSchema::typeRef(Aggregate::BUILDING) )); } } The refactored BuildingFinder looks like this:&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use App\\Api\\Query; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use React\\Promise\\Deferred; final class BuildingFinder { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $collectionName; public function __construct(string $collectionName, DocumentStore $documentStore) { $this-&gt;collectionName = $collectionName; $this-&gt;documentStore = $documentStore; } public function __invoke(Message $buildingQuery, Deferred $deferred): void { switch ($buildingQuery-&gt;messageName()) { case Query::BUILDING: $this-&gt;resolveBuilding($deferred, $buildingQuery-&gt;get('buildingId')); break; case Query::BUILDINGS: $this-&gt;resolveBuildings($deferred, $buildingQuery-&gt;getOrDefault('name', null)); break; } } private function resolveBuilding(Deferred $deferred, string $buildingId): void { $buildingDoc = $this-&gt;documentStore-&gt;getDoc($this-&gt;collectionName, $buildingId); if(!$buildingDoc) { $deferred-&gt;reject(new \\RuntimeException('Building not found', 404)); return; } $deferred-&gt;resolve($buildingDoc); } private function resolveBuildings(Deferred $deferred, string $nameFilter = null): array { $filter = $nameFilter? new DocumentStore\\Filter\\LikeFilter('name', \"%$nameFilter%\") : new DocumentStore\\Filter\\AnyFilter(); $cursor = $this-&gt;documentStore-&gt;filterDocs($this-&gt;collectionName, $filter); $deferred-&gt;resolve(iterator_to_array($cursor)); } } BuildingFinder can resolve both queries by mapping the query name to an internal resolve* method. For the new Buildings query the finder makes use of DocumentStore\\Filters. The LikeFilter works the same way as a SQL like expression using % as a placeholder. AnyFilter matches any documents in the collection. There are many more filters available. Read more about filters in the docs.You can test the new query using Swagger. This is an example query with a name filter:{ \"payload\": { \"name\": \"Acme\" } } You can add some more buildings and play with the queries. Try to exchange the LikeFilter with a EqFilter for example. Or see what happens if you pass an empty string as name filter.In part VI we got back to the write model and learned how to work with process managers. But before we continue, we should clean up our code a bit. Part V tells you what we can improve."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partV.html#2-6","title":"Part V - DRY","content":"You may have noticed that we use the static classes in src\/Api as a central place to define constants. At least we did that for message (Command, Event, Query) and aggregate names. We did not touch src\/Api\/Payload and src\/Api\/Schema yet.The idea behind those two classes is to group some common constants and static methods so that we don't have to repeat them over and over again. This makes it much easier to refactor the codebase later."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partV.html#2-6-1","title":"Payload","content":"In src\/Api\/Payload we simply define a constant for each possible message payload key. We've used two keys so far: buildingId and name so we should add them ...&lt;?php declare(strict_types=1); namespace App\\Api; class Payload { \/\/Predefined keys for query payloads, see App\\Api\\Schema::queryPagination() for further information const SKIP = 'skip'; const LIMIT = 'limit'; const BUILDING_ID = 'buildingId'; const NAME = 'name'; } ... and replace plain strings with the constants in our codebase:src\/Api\/Aggregate&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy(Payload::BUILDING_ID) \/\/&lt;-- AggregateId payload property -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED) -&gt;apply([Building::class, 'whenBuildingAdded']); \/* ... *\/ } } src\/Api\/Command&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const ADD_BUILDING = 'AddBuilding'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ Payload::BUILDING_ID =&gt; JsonSchema::uuid(), Payload::NAME =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } src\/Api\/Event&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ Payload::BUILDING_ID =&gt; JsonSchema::uuid(), Payload::NAME =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } src\/Api\/Query&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\BuildingFinder; use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; const BUILDINGS = 'Buildings'; public static function describe(EventMachine $eventMachine): void { \/\/Default query: can be used to check if service is up and running $eventMachine-&gt;registerQuery(self::HEALTH_CHECK) \/\/&lt;-- Payload schema is optional for queries -&gt;resolveWith(HealthCheckResolver::class) \/\/&lt;-- Service id (usually FQCN) to get resolver from DI container -&gt;setReturnType(Schema::healthCheck()); \/\/&lt;-- Type returned by resolver $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ Payload::BUILDING_ID =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(JsonSchema::typeRef(Aggregate::BUILDING)); $eventMachine-&gt;registerQuery( self::BUILDINGS, JsonSchema::object( [], [Payload::NAME =&gt; JsonSchema::nullOr(JsonSchema::string()-&gt;withMinLength(1))] ) ) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(JsonSchema::array( JsonSchema::typeRef(Aggregate::BUILDING) )); } } src\/Infrastructure\/Finder\/BuildingFinder&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use App\\Api\\Payload; use App\\Api\\Query; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use React\\Promise\\Deferred; final class BuildingFinder { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $collectionName; public function __construct(string $collectionName, DocumentStore $documentStore) { $this-&gt;collectionName = $collectionName; $this-&gt;documentStore = $documentStore; } public function __invoke(Message $buildingQuery, Deferred $deferred): void { switch ($buildingQuery-&gt;messageName()) { case Query::BUILDING: $this-&gt;resolveBuilding($deferred, $buildingQuery-&gt;get(Payload::BUILDING_ID)); break; case Query::BUILDINGS: $this-&gt;resolveBuildings($deferred, $buildingQuery-&gt;getOrDefault(Payload::NAME, null)); break; } } private function resolveBuilding(Deferred $deferred, string $buildingId): void { $buildingDoc = $this-&gt;documentStore-&gt;getDoc($this-&gt;collectionName, $buildingId); if(!$buildingDoc) { $deferred-&gt;reject(new \\RuntimeException('Building not found', 404)); return; } $deferred-&gt;resolve($buildingDoc); } private function resolveBuildings(Deferred $deferred, string $nameFilter = null): array { $filter = $nameFilter? new DocumentStore\\Filter\\LikeFilter(Payload::NAME, \"%$nameFilter%\") : new DocumentStore\\Filter\\AnyFilter(); $cursor = $this-&gt;documentStore-&gt;filterDocs($this-&gt;collectionName, $filter); $deferred-&gt;resolve(iterator_to_array($cursor)); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partV.html#2-6-2","title":"Schema","content":"Schema definitions are another area where DRY (Don't Repeat Yourself) makes a lot of sense. A good practice is to define a schema for each payload key and reuse it when registering messages. Type references (JsonSchema::typeRef) should also be wrapped by a schema method. Open src\/Api\/Schema and add the static methods:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\StringType; use Prooph\\EventMachine\\JsonSchema\\Type\\TypeRef; use Prooph\\EventMachine\\JsonSchema\\Type\\UuidType; class Schema { public static function buildingId(): UuidType { return JsonSchema::uuid(); } public static function buildingName(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } public static function buildingNameFilter(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } public static function building(): TypeRef { return JsonSchema::typeRef(Aggregate::BUILDING); } public static function buildingList(): ArrayType { return JsonSchema::array(self::building()); } \/* ... *\/ } Doing this creates one place that gives us an overview of all domain specific schema definitions and we can simply change them if requirements change.Note: Even if we only use \"name\" in message payload for building names we use a more precise method name in Schema. A message defines the context so we can use a shorter payload key but the schema should be explicit.You can now replace all schema definitions.src\/Api\/Command&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const ADD_BUILDING = 'AddBuilding'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::buildingName(), ] ) ); } } src\/Api\/Event&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::buildingName(), ] ) ); } } src\/Api\/Query&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\BuildingFinder; use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; const BUILDINGS = 'Buildings'; public static function describe(EventMachine $eventMachine): void { \/\/Default query: can be used to check if service is up and running $eventMachine-&gt;registerQuery(self::HEALTH_CHECK) \/\/&lt;-- Payload schema is optional for queries -&gt;resolveWith(HealthCheckResolver::class) \/\/&lt;-- Service id (usually FQCN) to get resolver from DI container -&gt;setReturnType(Schema::healthCheck()); \/\/&lt;-- Type returned by resolver $eventMachine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), ])) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(Schema::building()); $eventMachine-&gt;registerQuery( self::BUILDINGS, JsonSchema::object( [], [Payload::NAME =&gt; JsonSchema::nullOr(Schema::buildingNameFilter())] ) ) -&gt;resolveWith(BuildingFinder::class) -&gt;setReturnType(Schema::buildingList()); } } We're done with the refactoring and ready to add the next use case. Head over to part VI."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7","title":"Part VI - Check in User","content":"The second use case of our Building Management system checks users into buildings. Users are identified by their name."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-1","title":"Command","content":"Let's add a new command for the use case in src\/Api\/Command:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const ADD_BUILDING = 'AddBuilding'; const CHECK_IN_USER = 'CheckInUser'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerCommand( Command::CHECK_IN_USER, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::username(), ]) ); } } We can reuse Payload::NAME but assign a different schema so that we can change schema for a building name without influencing the schema of user name:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\ArrayType; use Prooph\\EventMachine\\JsonSchema\\Type\\StringType; use Prooph\\EventMachine\\JsonSchema\\Type\\TypeRef; use Prooph\\EventMachine\\JsonSchema\\Type\\UuidType; class Schema { \/* ... *\/ public static function username(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-2","title":"Event","content":"&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; const USER_CHECKED_IN = 'UserCheckedIn'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::buildingName(), ] ) ); $eventMachine-&gt;registerEvent( self::USER_CHECKED_IN, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::username(), ]) ); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-3","title":"Aggregate","content":"Did you notice that we are getting faster? Once, you're used to Event Machine's API you can develop at the speed of light ;).A user can only check into an existing building. builidngId is part of the command payload and should reference a building in our system. For the command handling aggregate function this means that we also have state of the aggregate and Event Machine will pass that state as the first argument to the command handling function as well as to the event apply function:&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } public static function checkInUser(Building\\State $state, Message $checkInUser): \\Generator { yield [Event::USER_CHECKED_IN, $checkInUser-&gt;payload()]; } public static function whenUserCheckedIn(Building\\State $state, Message $userCheckedIn): Building\\State { return $state-&gt;withCheckedInUser($userCheckedIn-&gt;get(Payload::NAME)); } } Building::checkInUser() is still a dumb function (we will change that in a minute) but Building::whenUserCheckedIn() contains an interesting detail. Building\\State is an immutable record. But we can add with* methods to it to modify state. You may know these with* methods from the PSR-7 standard. It is a common practice to prefix state changing methods of immutable objects with with. Those methods should return a new instance with the modified state rather than changing its own state. Here is the implementation of Building\\State::withCheckedInUser(string $username): Building\\State:&lt;?php declare(strict_types=1); namespace App\\Model\\Building; use App\\Api\\Schema; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type; final class State implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var string *\/ private $buildingId; \/** * @var string *\/ private $name; \/** * @var array *\/ private $users = []; private static function arrayPropItemTypeMap(): array { return ['users' =&gt; JsonSchema::TYPE_STRING]; } \/** * @return string *\/ public function buildingId(): string { return $this-&gt;buildingId; } \/** * @return string *\/ public function name(): string { return $this-&gt;name; } \/** * @return array *\/ public function users(): array { return array_keys($this-&gt;users); } public function withCheckedInUser(string $username): State { $copy = clone $this; $copy-&gt;users[$username] = null; return $copy; } public function isUserCheckedIn(string $username): bool { return array_key_exists($username, $this-&gt;users); } } We can make a copy of the record and modify that. The original record is not modified, and we return the copy to satisfy the immutable record contract.Besides withCheckedInUser we've added a new property, users, and a getter for it. We also overrode the private static method arrayPropItemTypeMap of ImmutableRecordLogic to define a type hint for the items in the users array property. Unfortunately, we can only type hint for array in PHP, and it is not possible to use return type hints like string[]. Hopefully this will change in a future version of PHP, but, for now, we have to live with the workaround and give ImmutableRecordLogic a hint that array items of the users property are of type string.Note: ImmutableRecordLogic derives type information by inspecting return types of getter methods named like their corresponding private properties.Internally, user names are used as the array index so the same user cannot appear twice in the list. With Building\\State::isUserCheckedIn(string $username): bool we can look up if the given user is currently in the building. Building\\State::users() on the other hand returns a list of user names like defined in the __schema. Internal state is used for fast look ups and external schema is used for the read model. More on that in a minute."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-4","title":"Command Processing","content":"&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;process(Command::CHECK_IN_USER) -&gt;withExisting(self::BUILDING) -&gt;handle([Building::class, 'checkInUser']) -&gt;recordThat(Event::USER_CHECKED_IN) -&gt;apply([Building::class, 'whenUserCheckedIn']); } } Pretty much the same command processing description but with command, event and function names based on the new use case. An important difference is that we use -&gt;withExisting instead of -&gt;withNew. As already stated this tells Event Machine to look up an existing Building using the buildingId from the CheckInUser command.The following command should check in John into the Acme Headquarters.{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } } Looks good! And what does the response of the Buildings query look now? If you inspect the schema of the query and click on the Building return type you'll notice the new property users.{ \"payload\": { \"name\": \"Acme\" } } Response[ { \"name\": \"Acme Headquarters\", \"users\": [ \"John\" ], \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } ] Great! We get back the list of users checked into the building."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVI.html#2-7-5","title":"Protect Invariants","content":"One of the main tasks of an aggregate is to protect invariants. A user cannot check in twice. The Building aggregate should enforce the business rule:&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } public static function checkInUser(Building\\State $state, Message $checkInUser): \\Generator { if($state-&gt;isUserCheckedIn($checkInUser-&gt;get(Payload::NAME))) { throw new \\DomainException(sprintf( \"User %s is already in the building\", $checkInUser-&gt;get(Payload::NAME) )); } yield [Event::USER_CHECKED_IN, $checkInUser-&gt;payload()]; } public static function whenUserCheckedIn(Building\\State $state, Message $userCheckedIn): Building\\State { return $state-&gt;withCheckedInUser($userCheckedIn-&gt;get(Payload::NAME)); } } The command handling function can make use of $state passed to it as this will always be the current state of the aggregate. If the given user is already checked in we throw an exception to stop command processing.Let's try it:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } } Response:{ \"error\": { \"message\": \"User John is already in the building\", \"details\": \"...\" } } Throwing an exception is the simplest way to protect invariants. However, with event sourcing we have a different (and in most cases) better option. This will be covered in the next part of the tutorial."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVII.html#2-8","title":"Part VII - The Unhappy Path","content":"Developers tend to work out the happy path of a feature only and throw exceptions in every unknown situation. This behaviour is often caused by bad project management. Developers get domain knowledge from Jira tickets written by a product owner (Jira is used here as a synonym for any ticket system used in an agile process) instead of talking to domain experts face-to-face. Most tickets don't include unhappy paths until they happen and find their way back to the developer as a bug ticket.Is this really the best way to deal with unexpected scenarios? Wouldn't it be better to prepare for the unhappy paths as well? Sure, it takes more time upfront but saves a lot of time later when the application runs in production and can deal with failure scenarios in a sane way.Our Building aggregate does a bad job with regards to failure handling. Imagine a user is already in a building and tries to check in again. What does that mean in the real world? First of all it is not possible to be in and out of a building at the same time. So either a hacker has stolen the identity or system state is broken for whatever reason. Deciding if entrance to the building is blocked or not should be made by the business. And regardless of the decision it is always interesting to have an event in the event stream about the double check in. This makes monitoring much simpler than scanning error logs.We've talked to the domain experts and they want us to notify security in case of a DoubleCheckIn. With Event Machine this is as simple as throwing an exception ;)We need an event to record a DoubleCheckIn:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; const USER_CHECKED_IN = 'UserCheckedIn'; const DOUBLE_CHECK_IN_DETECTED = 'DoubleCheckInDetected'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerEvent( self::DOUBLE_CHECK_IN_DETECTED, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::username(), ]) ); } } Now that we have the event we can replace the exception and yield a DoubleCheckInDetected event instead:&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Api\\Event; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } public static function checkInUser(Building\\State $state, Message $checkInUser): \\Generator { if($state-&gt;isUserCheckedIn($checkInUser-&gt;get(Payload::NAME))) { yield [Event::DOUBLE_CHECK_IN_DETECTED, $checkInUser-&gt;payload()]; return; \/\/&lt;-- Note: we need to return, otherwise UserCheckedIn would be yielded, too } yield [Event::USER_CHECKED_IN, $checkInUser-&gt;payload()]; } public static function whenUserCheckedIn(Building\\State $state, Message $userCheckedIn): Building\\State { return $state-&gt;withCheckedInUser($userCheckedIn-&gt;get(Payload::NAME)); } public static function whenDoubleCheckInDetected(Building\\State $state, Message $event): Building\\State { \/\/No state change required, simply return current state return $state; } } We need to tell Event Machine that Building::checkInUser() yields DoubleCheckInDetected in some situations:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;process(Command::CHECK_IN_USER) -&gt;withExisting(self::BUILDING) -&gt;handle([Building::class, 'checkInUser']) -&gt;recordThat(Event::USER_CHECKED_IN) -&gt;apply([Building::class, 'whenUserCheckedIn']) -&gt;orRecordThat(Event::DOUBLE_CHECK_IN_DETECTED) -&gt;apply([Building::class, 'whenDoubleCheckInDetected']); } } Try to check John in again:{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } } Instead of an error we get a 202 command accepted response.But when we look at the event stream (table _4228e4a00331b5d5e751db0481828e22a2c3c8ef) we see a DoubleCheckInDetected event. no event_id event_name payload metadata created_at 1 bce42506-... BuildingAdded {\"buildingId\":\"9ee8d8a8-...\",\"name\":\"Acme Headquarters\"} {\"_aggregate_id\": \"9ee8d8a8-...\", \"_causation_id\": \"e482f5b8-...\", \"_aggregate_type\": \"Building\", \"_causation_name\": \"AddBuilding\", \"_aggregate_version\": 1} 2018-02-14 22:09:32.039848 2 0ee8d2fb-... UserCheckedIn {\"buildingId\":\"9ee8d8a8-...\",\"name\":\"John\"} {\"_aggregate_id\": \"9ee8d8a8-...\", \"_causation_id\": \"1ce0e46d-...\", \"_aggregate_type\": \"Building\", \"_causation_name\": \"CheckInUser\", \"_aggregate_version\": 2} 2018-02-16 21:37:55.131122 3 4f6a8429-... DoubleCheckInDetected {\"buildingId\":\"9ee8d8a8-...\",\"name\":\"John\"} {\"_aggregate_id\": \"9ee8d8a8-...\", \"_causation_id\": \"c347dd85-...\", \"_aggregate_type\": \"Building\", \"_causation_name\": \"CheckInUser\", \"_aggregate_version\": 3} 2018-02-16 23:03:59.739666 "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVII.html#2-8-1","title":"Process Manager","content":"To complete the user story we have to notify security. The security team uses a dedicated monitoring application that can receive arbitrary notification messages. To communicate with that external system we can use a so-called process manager or policy. Maybe you're more familiar with the term event listener but be careful to not mix it with event listeners known from web frameworks like Symfony or Zend. Listeners in Event Machine react to domain events and trigger follow up commands for actions, like sending emails or interacting with external systems.We can simulate the security monitoring system with a small JS app shipped with the event-machine-skeleton. Open http:\/\/localhost:8080\/ws.html in your browser.Note: If the app shows a connection error then try to log into the rabbit mgmt console first: https:\/\/localhost:8081. Accept the self-signed certificate and login with usr: prooph pwd: prooph. If you're logged in switch back to http:\/\/localhost:8080\/ws.html and reload the page.If the app says Status: Connected to websocket: ui-queue it is ready to receive messages from Event Machine.In src\/Service\/ServiceFactory you can find a factory method for a App\\Infrastructure\\ServiceBus\\UiExchange. It's a default domain event listener shipped with the skeleton that can be used to push events on a RabbitMQ ui-exchange. The exchange is preconfigured (you can see that in the rabbit mgmt UI) and the JS app connects to a corresponding ui-queue.In src\/Api\/Listener we can put together the pieces:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\ServiceBus\\UiExchange; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Listener implements EventMachineDescription { public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;on(Event::DOUBLE_CHECK_IN_DETECTED, UiExchange::class); } } Whenever a DoubleCheckInDetected event is recorded and written to the stream Event Machine invokes the UiExchange listener that takes the event and pushes it to rabbit.Try to check John in again, while keeping an eye on the monitoring app http:\/\/localhost:8080\/ws.html.{ \"payload\": { \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } } ]"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/partVII.html#2-8-2","title":"The End","content":"Congratulations! You've mastered the Event Machine tutorial. There are two bonus parts available to learn more about custom projections and testing with Event Machine. And another two bonus parts introduce Event Machine Flavours. Choose your own Flavour and maximize your very personal developer experience with Event Machine.The current implementation is available as a demo branch of proophsoftware\/event-machine-skeleton.The Event Machine API docs contain a lot more details. Last but not least, a reminder that the prooph software team offers commercial project support and workshops for Event Machine and the prooph components.Our workshops include Event Storming sessions and guidance on how to turn the results into working prototypes using Event Machine. We can also show and discuss framework integrations. Event Machine can easily be integrated with Symfony, Laravel and other PHP web frameworks. The skeleton is based on Zend Strategility so you can handle http related tasks, like authentication, using PSR-15 middleware. But again, other web frameworks play nicely with Event Machine, too.If you are interested please get in touch!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusI.html#2-9","title":"Bonus I - Custom Projection","content":"The product owner comes along with a new feature request. They need a way to look up the building a user is checked into, if any."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusI.html#2-9-1","title":"Exercise","content":"Before we implement that feature you're asked to implement the check out user use case. Add a command CheckOutUser and an event UserCheckedOut. Let the Building aggregate and Building\\State handle the command and make sure that DoubleCheckOutDetected can also be monitored using the monitoring UI.Does it work? Great!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusI.html#2-9-2","title":"Implement a Projector","content":"What we need is a list of usernames and a reference to the building they are checked into. A custom projection can keep track of UserCheckedIn and UserCheckedOut events to keep the list up-to-date.First check in John again (in case he is checked out because you've successfully tested the CheckOutUser command)!To do that we need our own Prooph\\EventMachine\\Projecting\\Projector implementation. Create a new class called UserBuildingList in src\/Infrastructure\/Projector with the following content:&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Projector; use App\\Api\\Event; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use Prooph\\EventMachine\\Projecting\\AggregateProjector; use Prooph\\EventMachine\\Projecting\\Projector; final class UserBuildingList implements Projector { \/** * @var DocumentStore *\/ private $documentStore; public function __construct(DocumentStore $documentStore) { $this-&gt;documentStore = $documentStore; } public function prepareForRun(string $appVersion, string $projectionName): void { if(!$this-&gt;documentStore-&gt;hasCollection($this-&gt;generateCollectionName($appVersion, $projectionName))) { $this-&gt;documentStore-&gt;addCollection( $this-&gt;generateCollectionName($appVersion, $projectionName) \/* Note: we could pass index configuration as a second argument, see docs for details *\/ ); } } public function handle(string $appVersion, string $projectionName, Message $event): void { $collection = $this-&gt;generateCollectionName($appVersion, $projectionName); switch ($event-&gt;messageName()) { case Event::USER_CHECKED_IN: $this-&gt;documentStore-&gt;addDoc( $collection, $event-&gt;get(Payload::NAME), \/\/Use username as doc id [Payload::BUILDING_ID =&gt; $event-&gt;get(Payload::BUILDING_ID)] ); break; case Event::USER_CHECKED_OUT: $this-&gt;documentStore-&gt;deleteDoc($collection, $event-&gt;get(Payload::NAME)); break; default: \/\/Ignore unknown events } } public function deleteReadModel(string $appVersion, string $projectionName): void { $this-&gt;documentStore-&gt;dropCollection($this-&gt;generateCollectionName($appVersion, $projectionName)); } private function generateCollectionName(string $appVersion, string $projectionName): string { \/\/We can use the naming strategy of the aggregate projector for our custom projection, too return AggregateProjector::generateCollectionName($appVersion, $projectionName); } } Make the projector available as a service in src\/Service\/ServiceFactory:&lt;?php namespace App\\Service; use App\\Infrastructure\\Projector\\UserBuildingList; use ... final class ServiceFactory { use ServiceRegistry; \/** * @var ArrayReader *\/ private $config; \/** * @var ContainerInterface *\/ private $container; \/* ... *\/ \/\/Finders public function buildingFinder(): BuildingFinder { return $this-&gt;makeSingleton(BuildingFinder::class, function () { return new BuildingFinder( AggregateProjector::aggregateCollectionName( $this-&gt;eventMachine()-&gt;appVersion(), Aggregate::BUILDING ), $this-&gt;documentStore() ); }); } \/\/Projectors public function userBuildingListProjector(): UserBuildingList { return $this-&gt;makeSingleton(UserBuildingList::class, function () { return new UserBuildingList($this-&gt;documentStore()); }); } \/* ... *\/ } And describe the projector in src\/Api\/Projection:&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Projector\\UserBuildingList; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\Persistence\\Stream; class Projection implements EventMachineDescription { const USER_BUILDING_LIST = 'user_building_list'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;watch(Stream::ofWriteModel()) -&gt;withAggregateProjection(Aggregate::BUILDING); $eventMachine-&gt;watch(Stream::ofWriteModel()) -&gt;with(self::USER_BUILDING_LIST, UserBuildingList::class) -&gt;filterEvents([ Event::USER_CHECKED_IN, Event::USER_CHECKED_OUT, ]); } } If you look at the Postgres DB you should see a new table called em_ds_user_building_list_0_1_0 but the table is empty. We can reset the long-running projection process used by Event Machine and therefor recreate all read models. This will fill the new read model with data from the past. That's cool, isn't it?Run the command docker-compose run php php bin\/reset.php in the project directory and check the table again.Here we go: id doc John {\"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\"} If the table is empty make sure that you've checked in John. If that's the case, your projection might have a problem. Check the troubleshooting section of Event Machine's README."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusI.html#2-9-3","title":"Look up","content":"We can add a new query, finder and corresponding type definitions to complete the look up feature.src\/Api\/Type&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\ObjectType; class Type implements EventMachineDescription { const HEALTH_CHECK = 'HealthCheck'; const USER_BUILDING = 'UserBuilding'; \/\/&lt;-- new type \/* ... *\/ private static function userBuilding(): ObjectType { return JsonSchema::object([ 'user' =&gt; Schema::username(), 'building' =&gt; Schema::building()-&gt;asNullable(), \/\/&lt;-- type ref to building, can be null ]); } \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { \/\/Register the HealthCheck type returned by @see \\App\\Api\\Query::HEALTH_CHECK $eventMachine-&gt;registerType(self::HEALTH_CHECK, self::healthCheck()); $eventMachine-&gt;registerType(Aggregate::BUILDING, Building\\State::__schema()); $eventMachine-&gt;registerType(self::USER_BUILDING, self::userBuilding()); \/\/&lt;-- type registration } } src\/Api\/Schema&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; use Prooph\\EventMachine\\JsonSchema\\Type\\ArrayType; use Prooph\\EventMachine\\JsonSchema\\Type\\StringType; use Prooph\\EventMachine\\JsonSchema\\Type\\TypeRef; use Prooph\\EventMachine\\JsonSchema\\Type\\UuidType; class Schema { \/* ... *\/ public static function username(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } public static function userBuilding(): TypeRef { return JsonSchema::typeRef(Type::USER_BUILDING); } \/* ... *\/ } src\/Infrastructure\/Finder\/UserBuildingFinder&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use App\\Api\\Payload; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Persistence\\DocumentStore; use React\\Promise\\Deferred; final class UserBuildingFinder { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $userBuildingCollection; \/** * @var string *\/ private $buildingCollection; public function __construct(DocumentStore $documentStore, string $userBuildingCol, string $buildingCol) { $this-&gt;documentStore = $documentStore; $this-&gt;userBuildingCollection = $userBuildingCol; $this-&gt;buildingCollection = $buildingCol; } public function __invoke(Message $query, Deferred $deferred): void { $userBuilding = $this-&gt;documentStore-&gt;getDoc( $this-&gt;userBuildingCollection, $query-&gt;get(Payload::NAME) ); if(!$userBuilding) { $deferred-&gt;resolve([ 'user' =&gt; $query-&gt;get(Payload::NAME), 'building' =&gt; null ]); return; } $building = $this-&gt;documentStore-&gt;getDoc( $this-&gt;buildingCollection, $userBuilding['buildingId'] ); if(!$building) { $deferred-&gt;resolve([ 'user' =&gt; $query-&gt;get(Payload::NAME), 'building' =&gt; null ]); return; } $deferred-&gt;resolve([ 'user' =&gt; $query-&gt;get(Payload::NAME), 'building' =&gt; $building ]); return; } } src\/Service\/ServiceFactory&lt;?php namespace App\\Service; use App\\Infrastructure\\Finder\\UserBuildingFinder; use ... final class ServiceFactory { use ServiceRegistry; \/** * @var ArrayReader *\/ private $config; \/** * @var ContainerInterface *\/ private $container; \/* ... *\/ \/\/Finders public function userBuildingFidner(): UserBuildingFinder { return $this-&gt;makeSingleton(UserBuildingFinder::class, function () { return new UserBuildingFinder( $this-&gt;documentStore(), AggregateProjector::generateCollectionName( $this-&gt;eventMachine()-&gt;appVersion(), Projection::USER_BUILDING_LIST ), AggregateProjector::aggregateCollectionName( $this-&gt;eventMachine()-&gt;appVersion(), Aggregate::BUILDING ) ); }); } \/* ... *\/ } src\/Api\/Query&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\UserBuildingFinder; use ... class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ \/* ... *\/ const USER_BUILDING = 'UserBuilding'; public static function describe(EventMachine $eventMachine): void { \/* ... *\/ $eventMachine-&gt;registerQuery( self::USER_BUILDING, JsonSchema::object(['name' =&gt; Schema::username()]) ) -&gt;resolveWith(UserBuildingFinder::class) -&gt;setReturnType(Schema::userBuilding()); } } Swagger - UserBuilding query{ \"payload\": { \"name\": \"John\" } } Response{ \"user\": \"John\", \"building\": { \"name\": \"Acme Headquarters\", \"users\": [ \"John\" ], \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } } An hour of work (with a bit more practice even less) and we are ready to ship the new feature! Rapid application development at its best! RAD is ok, but please don't skip testing! In the second bonus part of the tutorial we'll learn that Event Machine makes it easy to run integration tests. Don't miss it!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10","title":"Bonus II - Unit and Integration Tests","content":"Unit testing the different parts of the application is easy. In most cases we have single purpose classes and functions that can be tested without mocking."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10-1","title":"Testing Aggregate functions","content":"Aggregate functions are pure which makes them easy to test. event-machine-skeleton provides some test helpers in tests\/BaseTestCase.php, so, if you extend from that base class, you're ready to go. Add a folder Model in tests and a class BuildingTest with the following content:&lt;?php declare(strict_types=1); namespace AppTest\\Model; use App\\Api\\Command; use App\\Api\\Event; use App\\Api\\Payload; use AppTest\\BaseTestCase; use Ramsey\\Uuid\\Uuid; use App\\Model\\Building; class BuildingTest extends BaseTestCase { private $buildingId; private $buildingName; private $username; protected function setUp() { $this-&gt;buildingId = Uuid::uuid4()-&gt;toString(); $this-&gt;buildingName = 'Acme Headquarters'; $this-&gt;username = 'John'; parent::setUp(); } \/** * @test *\/ public function it_checks_in_a_user() { \/\/Prepare expected aggregate state $state = Building\\State::fromArray([ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;buildingName ]); \/\/Use test helper BaseTestCase::message() to construct command $command = $this-&gt;message(Command::CHECK_IN_USER, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username, ]); \/\/Aggregate functions yield events which turns them into Generators (special type of an Iterator) $events = iterator_to_array( Building::checkInUser($state, $command) ); \/\/Another test helper to assert that list of recorded events contains given event $this-&gt;assertRecordedEvent(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username ], $events); } \/** * @test *\/ public function it_detects_double_check_in() { \/\/Prepare expected aggregate state $state = Building\\State::fromArray([ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;buildingName ]); $state = $state-&gt;withCheckedInUser($this-&gt;username); \/\/Use test helper BaseTestCase::message() to construct command $command = $this-&gt;message(Command::CHECK_IN_USER, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username, ]); \/\/Aggregate functions yield events which turns them into Generators (special type of an Iterator) $events = iterator_to_array( Building::checkInUser($state, $command) ); \/\/Another test helper to assert that list of recorded events contains given event $this-&gt;assertRecordedEvent(Event::DOUBLE_CHECK_IN_DETECTED, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username ], $events); \/\/And the other way round, list should not contain event with given name $this-&gt;assertNotRecordedEvent(Event::USER_CHECKED_IN, $events); } } You can run tests with:docker-compose run php php vendor\/bin\/phpunit "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10-2","title":"Testing Projectors","content":"Testing projectors is also easy when they use the DocumentStore API to manage projections. Event Machine ships with an InMemoryDocumentStore implementation that works great in test cases. Here is an example:tests\/Infrastructure\/Projector\/UserBuildingListTest.php&lt;?php declare(strict_types=1); namespace AppTest\\Infrastructure\\Projector; use App\\Api\\Event; use App\\Api\\Payload; use App\\Infrastructure\\Projector\\UserBuildingList; use AppTest\\BaseTestCase; use Prooph\\EventMachine\\Persistence\\DocumentStore; use Prooph\\EventMachine\\Persistence\\InMemoryConnection; use Prooph\\EventMachine\\Projecting\\AggregateProjector; final class UserBuildingListTest extends BaseTestCase { const APP_VERSION = '0.1.0'; const PROJECTION_NAME = 'user_building_list'; const BUILDING_ID = '7c5f0c8a-54f2-4969-9596-b5bddc1e9421'; const USERNAME1 = 'John'; const USERNAME2 = 'Jane'; \/** * @var DocumentStore *\/ private $documentStore; \/** * @var UserBuildingList *\/ private $projector; protected function setUp() { parent::setUp(); $this-&gt;documentStore = new DocumentStore\\InMemoryDocumentStore(new InMemoryConnection()); $this-&gt;projector = new UserBuildingList($this-&gt;documentStore); $this-&gt;projector-&gt;prepareForRun(self::APP_VERSION, self::PROJECTION_NAME); } \/** * @test *\/ public function it_manages_list_of_users_with_building_reference() { $collection = AggregateProjector::generateCollectionName(self::APP_VERSION, self::PROJECTION_NAME); $johnCheckedIn = $this-&gt;message(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME1 ]); $this-&gt;projector-&gt;handle(self::APP_VERSION, self::PROJECTION_NAME, $johnCheckedIn); $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs($collection, new DocumentStore\\Filter\\AnyFilter())); $this-&gt;assertEquals($users, [ 'John' =&gt; ['buildingId' =&gt; self::BUILDING_ID] ]); $janeCheckedIn = $this-&gt;message(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME2 ]); $this-&gt;projector-&gt;handle(self::APP_VERSION, self::PROJECTION_NAME, $janeCheckedIn); $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs($collection, new DocumentStore\\Filter\\AnyFilter())); $this-&gt;assertEquals($users, [ 'John' =&gt; ['buildingId' =&gt; self::BUILDING_ID], 'Jane' =&gt; ['buildingId' =&gt; self::BUILDING_ID], ]); $johnCheckedOut = $this-&gt;message(Event::USER_CHECKED_OUT, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME1 ]); $this-&gt;projector-&gt;handle(self::APP_VERSION, self::PROJECTION_NAME, $johnCheckedOut); $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs($collection, new DocumentStore\\Filter\\AnyFilter())); $this-&gt;assertEquals($users, [ 'Jane' =&gt; ['buildingId' =&gt; self::BUILDING_ID], ]); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10-3","title":"Testing Finders","content":"Finders can be tested in the same manner as projectors, using the InMemoryDocumentStore with prefilled data. I will leave implementing these tests as an exercise for you ;)"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusII.html#2-10-4","title":"Integration Tests","content":"If you want to test the \"whole thing\" then you can make use of Event Machine's test mode. In test mode Event Machine is set up with an InMemoryEventStore and an InMemoryDocumentStore. A special PSR-11 container ensures that all other services are mocked. Let's see it in action. The annotated integration test should be self explanatory.tests\/Integration\/NotifySecurityTest.php&lt;?php declare(strict_types=1); namespace AppTest\\Integration; use App\\Api\\Command; use App\\Api\\Event; use App\\Api\\Payload; use App\\Infrastructure\\ServiceBus\\UiExchange; use AppTest\\BaseTestCase; use Prooph\\EventMachine\\Messaging\\Message; final class NotifySecurityTest extends BaseTestCase { const BUILDING_ID = '7c5f0c8a-54f2-4969-9596-b5bddc1e9421'; const BUILDING_NAME = 'Acme Headquarters'; const USERNAME = 'John'; private $uiExchange; protected function setUp() { \/\/The BaseTestCase loads all Event Machine descriptions configured in config\/autoload\/global.php parent::setUp(); \/\/Mock UiExchange with an anonymous class that keeps track of the last received message $this-&gt;uiExchange = new class implements UiExchange { private $lastReceivedMessage; public function __invoke(Message $event): void { $this-&gt;lastReceivedMessage = $event; } public function lastReceivedMessage(): Message { return $this-&gt;lastReceivedMessage; } }; } \/** * @test *\/ public function it_detects_double_check_in_and_notifies_security() { $this-&gt;eventMachine-&gt;bootstrapInTestMode( \/\/Add history events that should have been recorded before current test scenario [ $this-&gt;message(Event::BUILDING_ADDED, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::BUILDING_NAME ]), $this-&gt;message(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ]), ], \/\/Provide mocked services used in current test scenario, if you forget one the test will throw an exception \/\/You don't have to mock the event store and document store, that is done internally [ \/\/Remember, UiExchange is our process manager that pushes events to rabbit \/\/Event Machine is configured to push DoubleCheckInDetected events on to UiExchange (src\/Api\/Listener.php) UiExchange::class =&gt; $this-&gt;uiExchange ] ); \/\/Try to check in John twice $checkInJohn = $this-&gt;message(Command::CHECK_IN_USER, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ]); $this-&gt;eventMachine-&gt;dispatch($checkInJohn); \/\/After dispatch $this-&gt;lastPublishedEvent points to the event received by UiExchange mock $this-&gt;assertNotNull($this-&gt;uiExchange-&gt;lastReceivedMessage()); $this-&gt;assertEquals(Event::DOUBLE_CHECK_IN_DETECTED, $this-&gt;uiExchange-&gt;lastReceivedMessage()-&gt;messageName()); $this-&gt;assertEquals([ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ], $this-&gt;uiExchange-&gt;lastReceivedMessage()-&gt;payload()); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIII.html#2-11","title":"Bonus III - Functional Flavour","content":"Event Machine has a nice feature called Flavours. A Flavour lets you customize the way Event Machine interacts with your code. Throughout the tutorial we worked with the PrototypingFlavour, which is the default.As the name suggests, the PrototypingFlavour is optimized for rapid development. For example instead of defining classes for each type of message, Event Machine passes its default Message implementation to aggregate functions, process manager, finder and projectors. You don't need to care about serialization and mapping.If you want to try out new ideas, PrototypingFlavour is your best friend. Following Domain-Driven Design best practices Continuous Discovery and Agile Development are key drivers for successful projects. This requires experimentation and with the PrototypingFlavour it's easier than ever."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIII.html#2-11-1","title":"Harden The Domain Model","content":"Experimentation is great, but at some point you'll be satisfied with the domain model and want to turn it into a clean and robust implementation. That's very important for long-lived applications. Fortunately, Event Machine offers two additional Flavours. One is called the FunctionalFlavour and the other one OopFlavour. Finally, you can implement your own Prooph\\EventMachine\\Runtime\\Flavour to turn Event Machine into your very own CQRS \/ ES framework.First let's look at the FunctionalFlavour. It's similar to what we did so fare, except that explicit message types are used instead of generic Event Machine messages."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIII.html#2-11-2","title":"Functional Port","content":"The FunctionalFlavour requires an implementation of Prooph\\EventMachine\\Runtime\\Functional\\Port. Here you have to define custom mapping and serialization logic for message types. Create a new class AppMessagePort in src\/Infrastructure\/Flavour:&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Flavour; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Messaging\\MessageBag; use Prooph\\EventMachine\\Runtime\\Functional\\Port; final class AppMessagePort implements Port { \/** * @param Message $message * @return mixed The custom message *\/ public function deserialize(Message $message) { \/\/ TODO: Implement deserialize() method. } \/** * @param mixed $customMessage * @return array *\/ public function serializePayload($customMessage): array { \/\/ TODO: Implement serializePayload() method. } \/** * @param mixed $customEvent * @return MessageBag *\/ public function decorateEvent($customEvent): MessageBag { \/\/ TODO: Implement decorateEvent() method. } \/** * @param string $aggregateIdPayloadKey * @param mixed $command * @return string *\/ public function getAggregateIdFromCommand(string $aggregateIdPayloadKey, $command): string { \/\/ TODO: Implement getAggregateIdFromCommand() method. } \/** * @param mixed $customCommand * @param mixed $preProcessor Custom preprocessor * @return mixed Custom message *\/ public function callCommandPreProcessor($customCommand, $preProcessor) { \/\/ TODO: Implement callCommandPreProcessor() method. } \/** * @param mixed $customCommand * @param mixed $contextProvider * @return mixed *\/ public function callContextProvider($customCommand, $contextProvider) { \/\/ TODO: Implement callContextProvider() method. } } We'll implement the interface step by step and define a mapping strategy along the way."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIII.html#2-11-3","title":"Deserialize","content":"First method is deserialize:\/** * @param Message $message * @return mixed The custom message *\/ public function deserialize(Message $message) { \/\/ TODO: Implement deserialize() method. } An Event Machine message is passed as argument and the method should return a custom message. The first important decision is required:Which serialization technique do we want to use? Some people prefer handcrafted serialization, while others prefer conventions or serializers. The good news is, every technique can be used! It just needs to be implemented in the Port.To keep the tutorial simple, we're going to use the tools shipped with Event Machine. That said, our messages become ImmutableRecords and use the build-in serialization technique provided by ImmutableRecordLogic.The fact that messages are still coupled with the framework is not important here. It's our decision as developers to do it, but nothing required by Event Machine. We could also write our own serialization mechanism or use a third-party tool like FPP.Let's create some types and messages first:src\/Model\/Building\/BuildingId.php&lt;?php declare(strict_types=1); namespace App\\Model\\Building; use Ramsey\\Uuid\\Uuid; use Ramsey\\Uuid\\UuidInterface; final class BuildingId { private $buildingId; public static function generate(): self { return new self(Uuid::uuid4()); } public static function fromString(string $buildingId): self { return new self(Uuid::fromString($buildingId)); } private function __construct(UuidInterface $buildingId) { $this-&gt;buildingId = $buildingId; } public function toString(): string { return $this-&gt;buildingId-&gt;toString(); } public function equals($other): bool { if (!$other instanceof self) { return false; } return $this-&gt;buildingId-&gt;equals($other-&gt;buildingId); } public function __toString(): string { return $this-&gt;buildingId-&gt;toString(); } } src\/Model\/Building\/BuildingName.php&lt;?php declare(strict_types=1); namespace App\\Model\\Building; final class BuildingName { private $name; public static function fromString(string $name): self { return new self($name); } private function __construct(string $name) { $this-&gt;name = $name; } public function toString(): string { return $this-&gt;name; } public function equals($other): bool { if(!$other instanceof self) { return false; } return $this-&gt;name === $other-&gt;name; } public function __toString(): string { return $this-&gt;name; } } src\/Model\/Building\/Username.php&lt;?php declare(strict_types=1); namespace App\\Model\\Building; final class Username { private $name; public static function fromString(string $name): self { return new self($name); } private function __construct(string $name) { $this-&gt;name = $name; } public function toString(): string { return $this-&gt;name; } public function equals($other): bool { if(!$other instanceof self) { return false; } return $this-&gt;name === $other-&gt;name; } public function __toString(): string { return $this-&gt;name; } } src\/Model\/Building\/Command\/AddBuilding.php&lt;?php declare(strict_types=1); namespace App\\Model\\Building\\Command; use App\\Model\\Building\\BuildingId; use App\\Model\\Building\\BuildingName; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class AddBuilding implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var BuildingName *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return BuildingName *\/ public function name(): BuildingName { return $this-&gt;name; } } src\/Model\/Building\/Command\/CheckInUser.php&lt;?php declare(strict_types=1); namespace App\\Model\\Building\\Command; use App\\Model\\Building\\BuildingId; use App\\Model\\Building\\Username; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class CheckInUser implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var Username *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return Username *\/ public function name(): Username { return $this-&gt;name; } } src\/Model\/Building\/Command\/CheckOutUser.php&lt;?php declare(strict_types=1); namespace App\\Model\\Building\\Command; use App\\Model\\Building\\BuildingId; use App\\Model\\Building\\Username; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class CheckOutUser implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var Username *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return Username *\/ public function name(): Username { return $this-&gt;name; } } Ok, much more classes now. Each property has its own value object like BuildingId, BuildingName and Username. Again, that's not a requirement but it adds type safety to the implementation and serves as documentation. Don't worry about the amount of code. Most of it can be generated using PHPStorm templates. Event Machine docs contain useful tips. Another possibility is the already mentioned library FPP.With the value objects in place we've added a class for each command and implemented them as immutable records. Now we need a factory to instantiate a command with information taken from Event Machine messages. App\\Api\\Command already contains command specific information. Let's add the factory there.&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building\\Command\\AddBuilding; use App\\Model\\Building\\Command\\CheckInUser; use App\\Model\\Building\\Command\\CheckOutUser; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const ADD_BUILDING = 'AddBuilding'; const CHECK_IN_USER = 'CheckInUser'; const CHECK_OUT_USER = 'CheckOutUser'; const CLASS_MAP = [ self::ADD_BUILDING =&gt; AddBuilding::class, self::CHECK_IN_USER =&gt; CheckInUser::class, self::CHECK_OUT_USER =&gt; CheckOutUser::class, ]; public static function createFromNameAndPayload(string $commandName, array $payload) { $class = self::CLASS_MAP[$commandName] ?? false; if($class === false) { throw new \\InvalidArgumentException(\"Unknown command name: $commandName\"); } \/\/Commands use ImmutableRecordLogic and therefor have a fromArray method return $class::fromArray($payload); } public static function nameOf($command): string { $name = array_search(\\get_class($command), self::CLASS_MAP); if($name === false) { throw new \\InvalidArgumentException(\"Unknown command. Cannot find a name for class: \" . \\get_class($command)); } return $name; } \/* ... *\/ } Finally, the factory can be used in the Port:src\/Infrastructure\/Flavour\/AppMssagePort.php\/** * @param Message $message * @return mixed The custom message *\/ public function deserialize(Message $message) { switch ($message-&gt;messageType()) { case Message::TYPE_COMMAND: return Command::createFromNameAndPayload($message-&gt;messageName(), $message-&gt;payload()); break; } } A similar implementation is required for events and queries:src\/Model\/Building\/Event\/BuildingAdded.php&lt;?php declare(strict_types=1); namespace App\\Model\\Building\\Event; use App\\Model\\Building\\BuildingId; use App\\Model\\Building\\BuildingName; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class BuildingAdded implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var BuildingName *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return BuildingName *\/ public function name(): BuildingName { return $this-&gt;name; } } src\/Model\/Building\/Event\/UserCheckedIn.php&lt;?php declare(strict_types=1); namespace App\\Model\\Building\\Event; use App\\Model\\Building\\BuildingId; use App\\Model\\Building\\Username; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class UserCheckedIn implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var Username *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return Username *\/ public function name(): Username { return $this-&gt;name; } } src\/Model\/Building\/Event\/DoubleCheckInDetected.php&lt;?php declare(strict_types=1); namespace App\\Model\\Building\\Event; use App\\Model\\Building\\BuildingId; use App\\Model\\Building\\Username; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class DoubleCheckInDetected implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var Username *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return Username *\/ public function name(): Username { return $this-&gt;name; } } src\/Model\/Building\/Event\/UserCheckedOut.php&lt;?php declare(strict_types=1); namespace App\\Model\\Building\\Event; use App\\Model\\Building\\BuildingId; use App\\Model\\Building\\Username; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class UserCheckedOut implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var Username *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return Username *\/ public function name(): Username { return $this-&gt;name; } } src\/Model\/Building\/Event\/DoubleCheckOutDetected.php&lt;?php declare(strict_types=1); namespace App\\Model\\Building\\Event; use App\\Model\\Building\\BuildingId; use App\\Model\\Building\\Username; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class DoubleCheckOutDetected implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var Username *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return Username *\/ public function name(): Username { return $this-&gt;name; } } src\/Api\/Event.php&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building\\Event\\BuildingAdded; use App\\Model\\Building\\Event\\DoubleCheckInDetected; use App\\Model\\Building\\Event\\DoubleCheckOutDetected; use App\\Model\\Building\\Event\\UserCheckedIn; use App\\Model\\Building\\Event\\UserCheckedOut; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Event implements EventMachineDescription { const BUILDING_ADDED = 'BuildingAdded'; const USER_CHECKED_IN = 'UserCheckedIn'; const USER_CHECKED_OUT = 'UserCheckedOut'; const DOUBLE_CHECK_IN_DETECTED = 'DoubleCheckInDetected'; const DOUBLE_CHECK_OUT_DETECTED = 'DoubleCheckOutDetected'; const CLASS_MAP = [ self::BUILDING_ADDED =&gt; BuildingAdded::class, self::USER_CHECKED_IN =&gt; UserCheckedIn::class, self::USER_CHECKED_OUT =&gt; UserCheckedOut::class, self::DOUBLE_CHECK_IN_DETECTED =&gt; DoubleCheckInDetected::class, self::DOUBLE_CHECK_OUT_DETECTED =&gt; DoubleCheckOutDetected::class, ]; public static function createFromNameAndPayload(string $eventName, array $payload) { $class = self::CLASS_MAP[$eventName] ?? false; if($class === false) { throw new \\InvalidArgumentException(\"Unknown event name: $eventName\"); } \/\/Commands use ImmutableRecordLogic and therefor have a fromArray method return $class::fromArray($payload); } public static function nameOf($event): string { $name = array_search(\\get_class($event), self::CLASS_MAP); if($name === false) { throw new \\InvalidArgumentException(\"Unknown event. Cannot find a name for class: \" . \\get_class($event)); } return $name; } \/* ... *\/ } src\/Infrastructure\/Finder\/Query\/GetBuilding.php&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder\\Query; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class GetBuilding implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var string *\/ private $buildingId; \/** * @return string *\/ public function buildingId(): string { return $this-&gt;buildingId; } } src\/Infrastructure\/Finder\/Query\/GetBuildings.php&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder\\Query; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class GetBuildings implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var string|null *\/ private $name; \/** * @return null|string *\/ public function name(): ?string { return $this-&gt;name; } } src\/Infrastructure\/Finder\/Query\/GetUserBuildingList.php&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder\\Query; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class GetUserBuildingList implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var string *\/ private $name; \/** * @return string *\/ public function name(): string { return $this-&gt;name; } } src\/Api\/Query.php&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Finder\\BuildingFinder; use App\\Infrastructure\\Finder\\Query\\GetBuilding; use App\\Infrastructure\\Finder\\Query\\GetBuildings; use App\\Infrastructure\\Finder\\Query\\GetUserBuildingList; use App\\Infrastructure\\Finder\\UserBuildingFinder; use App\\Infrastructure\\System\\HealthCheckResolver; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Query implements EventMachineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; const BUILDINGS = 'Buildings'; const USER_BUILDING = 'UserBuilding'; const CLASS_MAP = [ self::BUILDING =&gt; GetBuilding::class, self::BUILDINGS =&gt; GetBuildings::class, self::USER_BUILDING =&gt; GetUserBuildingList::class, ]; public static function createFromNameAndPayload(string $queryName, array $payload) { if($queryName === self::HEALTH_CHECK) { return new MessageBag( self::HEALTH_CHECK, MessageBag::TYPE_QUERY, [] ); } $class = self::CLASS_MAP[$queryName] ?? false; if($class === false) { throw new \\InvalidArgumentException(\"Unknown query name: $queryName\"); } \/\/Commands use ImmutableRecordLogic and therefor have a fromArray method return $class::fromArray($payload); } public static function nameOf($query): string { if($query instanceof MessageBag) { return $query-&gt;messageName(); } $name = array_search(\\get_class($query), self::CLASS_MAP); if($name === false) { throw new \\InvalidArgumentException(\"Unknown query. Cannot find a name for class: \" . \\get_class($query)); } return $name; } \/* ... *\/ } src\/Infrastructure\/Flavour\/AppMssagePort.php\/** * @param Message $message * @return mixed The custom message *\/ public function deserialize(Message $message) { switch ($message-&gt;messageType()) { case Message::TYPE_COMMAND: return Command::createFromNameAndPayload($message-&gt;messageName(), $message-&gt;payload()); case Message::TYPE_EVENT: return Event::createFromNameAndPayload($message-&gt;messageName(), $message-&gt;payload()); case Message::TYPE_QUERY: return Query::createFromNameAndPayload($message-&gt;messageName(), $message-&gt;payload()); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIII.html#2-11-4","title":"Serialize Payload","content":"To convert our own message types to Event Machine messages we have to implement the serializePayload method:src\/Infrastructure\/Flavour\/AppMssagePort.php\/** * @param mixed $customMessage * @return array *\/ public function serializePayload($customMessage): array { if(is_array($customMessage)) { return $customMessage; } if(!$customMessage instanceof ImmutableRecord) { throw new \\RuntimeException( \"Invalid message passed to \" . __METHOD__ . \". Should be an immutable record, but got \" . (\\is_object($customMessage)? \\get_class($customMessage) : \\gettype($customMessage))); } return $customMessage-&gt;toArray(); } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIII.html#2-11-5","title":"Decorate Event","content":"decorateEvent is a special method called for each event yielded by an aggregate function. The expected return type is Prooph\\EventMachine\\Messaging\\MessageBag. You can think of it as an envelop for custom messages. The MessageBag can be used to add metadata information to events. Event Machine adds information like aggregate id, aggregate type, aggregate version, causation id (command id) and causation name (command name) by default. If you want to add additional metadata, just pass it to the MessageBag constructor (optional argument).Decorating a custom event with a MessageBas has the advantage that a custom message can be carried through the Event Machine layer without serialization. Event Machine assumes a normal message and adds aggregate specific metadata like described above. The MessageBag is then passed back to the configured flavour to call a corresponding apply function. The flavour can access the decorated event and pass it to the function. All without serialization in between.src\/Infrastructure\/Flavour\/AppMssagePort.php\/** * @param mixed $customEvent * @return MessageBag *\/ public function decorateEvent($customEvent): MessageBag { return new MessageBag( Event::nameOf($customEvent), MessageBag::TYPE_EVENT, $customEvent \/\/, [] &lt;- you could add additional metadata here ); } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIII.html#2-11-5-1","title":"Get Aggregate ID from Command","content":"Event Machine has a built-in way to locate existing aggregates using a generic command handler and repository. But it needs the correct aggregateId. Each command should contain the same aggregateId property. Remember that this information is part of an Event Machine description:src\/Api\/Aggregate&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy(Payload::BUILDING_ID) \/\/&lt;-- AggregateId payload property -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED) -&gt;apply([Building::class, 'whenBuildingAdded']); \/* ... *\/ } } Each Building command should have a builidngId property. Our newly created commands have buildingId() methods that we could call. An explicit implementation looks like this:\/** * @param string $aggregateIdPayloadKey * @param mixed $command * @return string *\/ public function getAggregateIdFromCommand(string $aggregateIdPayloadKey, $command): string { if($command instanceof AddBuilding || $command instanceof CheckInUser || $command instanceof CheckOutUser) { return $command-&gt;buildingId()-&gt;toString(); } throw new \\RuntimeException(\"Unknown command. Cannot get aggregate id from it. Got \" . get_class($command)); } But we would need to remember adding a new command here each time we add a new one to the system. That's annoying and interrupts the flow. Instead we can define an AggregateCommand interface that each command should implement.src\/Model\/Base\/AggregateCommand.php&lt;?php declare(strict_types=1); namespace App\\Model\\Base; interface AggregateCommand { public function aggregateId(): string; } src\/Model\/Building\/Command\/AddBuilding.php&lt;?php declare(strict_types=1); namespace App\\Model\\Building\\Command; use App\\Model\\Base\\AggregateCommand; use App\\Model\\Building\\BuildingId; use App\\Model\\Building\\BuildingName; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class AddBuilding implements ImmutableRecord, AggregateCommand \/\/&lt;-- Implement new interface { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var BuildingName *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return BuildingName *\/ public function name(): BuildingName { return $this-&gt;name; } public function aggregateId(): string \/\/&lt;-- new method { return $this-&gt;buildingId-&gt;toString(); } } Do the same for CheckInUser and CheckOutUser!Done? Great! Then we can change the Port to handle any AggregateCommand:src\/Infrastructure\/Flavour\/AppMssagePort.php\/** * @param string $aggregateIdPayloadKey * @param mixed $command * @return string *\/ public function getAggregateIdFromCommand(string $aggregateIdPayloadKey, $command): string { if($command instanceof AggregateCommand) { return $command-&gt;aggregateId(); } throw new \\RuntimeException(\"Unknown command. Cannot get aggregate id from it. Got \" . get_class($command)); } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIII.html#2-11-6","title":"Call Command Preprocessor","content":"We don't know command preprocessors yet. In short: a command preprocessor can be called before a command is passed to an aggregate function. This can be useful in cases where you want to enrich a command with additional information or perform advanced validation that is not covered by Json Schema. Read more about command preprocessors in the docs.Since we don't use one in the building application, we don't really need to implement the method. Let's assume that our future command preprocessors will be simple callables:src\/Infrastructure\/Flavour\/AppMssagePort.php\/** * @param mixed $customCommand * @param mixed $preProcessor Custom preprocessor * @return mixed Custom message *\/ public function callCommandPreProcessor($customCommand, $preProcessor) { if(is_callable($preProcessor)) { return $preProcessor($customCommand); } throw new \\RuntimeException(\"Cannot call preprocessor. Got \" . (is_object($preProcessor)? get_class($preProcessor) : gettype($preProcessor)) ); } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIII.html#2-11-7","title":"Call Context Provider","content":"Another concept that we don't know yet. A context provider can be used to inject context into aggregate functions. Again, read more about context providers in the docs.We're implementing a functional Flavour, so we expect a callable context provider passed to the port:src\/Infrastructure\/Flavour\/AppMssagePort.php\/** * @param mixed $customCommand * @param mixed $contextProvider * @return mixed *\/ public function callContextProvider($customCommand, $contextProvider) { if(is_callable($contextProvider)) { return $contextProvider($customCommand); } throw new \\RuntimeException(\"Cannot call context provider. Got \" . (is_object($contextProvider)? get_class($contextProvider) : gettype($contextProvider)) ); } All methods of the Functional\\Port are implemented. Good job! But we're not done yet."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIII.html#2-11-8","title":"Switching The Flavour","content":"Event Machine is looking for a Flavour in the app container passed to EventMachine::initialize(). With a new flavour method in the ServiceFactory we can provide one.src\/Service\/ServiceFactory.php&lt;?php namespace App\\Service; use App\\Infrastructure\\Flavour\\AppMessagePort; use Prooph\\EventMachine\\Runtime\\Flavour; use Prooph\\EventMachine\\Runtime\\FunctionalFlavour; \/* ... *\/ final class ServiceFactory { use ServiceRegistry; \/** * @var ArrayReader *\/ private $config; \/** * @var ContainerInterface *\/ private $container; public function __construct(array $appConfig) { $this-&gt;config = new ArrayReader($appConfig); } public function setContainer(ContainerInterface $container): void { $this-&gt;container = $container; } \/\/Flavour public function flavour(): Flavour { return $this-&gt;makeSingleton(Flavour::class, function () { return new FunctionalFlavour( new AppMessagePort() \/* * Additionally, inject a custom Prooph\\EventMachine\\Data\\DataConverter * if aggregate state does not implement ImmutableRecord! *\/ ); }); } \/* ... *\/ } Additionally, a service alias is required because Event Machine uses EventMachine::SERVICE_ID_FLAVOUR for look ups. Such an alias can be defined in config\/container.php (using the Event Machine Skeleton app):&lt;?php declare(strict_types = 1); $config = include 'config.php'; $serviceFactory = new \\App\\Service\\ServiceFactory($config); \/\/@TODO use cached serviceFactoryMap for production $container = new \\Prooph\\EventMachine\\Container\\ReflectionBasedContainer( $serviceFactory, [ \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_EVENT_STORE =&gt; \\Prooph\\EventStore\\EventStore::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_PROJECTION_MANAGER =&gt; \\Prooph\\EventStore\\Projection\\ProjectionManager::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_COMMAND_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\CommandBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_EVENT_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\EventBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_QUERY_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\QueryBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_DOCUMENT_STORE =&gt; \\Prooph\\EventMachine\\Persistence\\DocumentStore::class, \/\/Flavour alias \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_FLAVOUR =&gt; \\Prooph\\EventMachine\\Runtime\\Flavour::class, ] ); $serviceFactory-&gt;setContainer($container); return $container; Everything set up \u00f0\u009f\u008e\u0089. Refactoring can start!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIII.html#2-11-9","title":"Refactoring","content":"Switching the Flavour means all generic messages have to be replaced with their concrete implementations.In a larger project we might want to switch to another Flavour step by step. In that case a \"Proxy Flavour\" is required that uses PrototypingFlavour and FunctionalFlavour (or OopFlavour) internally together with a mapping of already migrated parts of the application.src\/Model\/Building.php&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Model\\Building\\Command\\AddBuilding; use App\\Model\\Building\\Command\\CheckInUser; use App\\Model\\Building\\Command\\CheckOutUser; use App\\Model\\Building\\Event\\BuildingAdded; use App\\Model\\Building\\Event\\DoubleCheckInDetected; use App\\Model\\Building\\Event\\DoubleCheckOutDetected; use App\\Model\\Building\\Event\\UserCheckedIn; use App\\Model\\Building\\Event\\UserCheckedOut; final class Building { public static function add(AddBuilding $addBuilding): \\Generator { yield BuildingAdded::fromArray($addBuilding-&gt;toArray()); } public static function whenBuildingAdded(BuildingAdded $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;toArray()); } public static function checkInUser(Building\\State $state, CheckInUser $checkInUser): \\Generator { if($state-&gt;isUserCheckedIn($checkInUser-&gt;name())) { yield DoubleCheckInDetected::fromArray($checkInUser-&gt;toArray()); return; } yield UserCheckedIn::fromArray($checkInUser-&gt;toArray()); } public static function whenUserCheckedIn(Building\\State $state, UserCheckedIn $userCheckedIn): Building\\State { return $state-&gt;withCheckedInUser($userCheckedIn-&gt;name()); } public static function whenDoubleCheckInDetected(Building\\State $state, DoubleCheckInDetected $event): Building\\State { \/\/No state change required, simply return current state return $state; } public static function checkOutUser(Building\\State $state, CheckOutUser $checkOutUser): \\Generator { if(!$state-&gt;isUserCheckedIn($checkOutUser-&gt;name())) { yield DoubleCheckOutDetected::fromArray($checkOutUser-&gt;toArray()); return; } yield UserCheckedOut::fromArray($checkOutUser-&gt;toArray()); } public static function whenUserCheckedOut(Building\\State $state, UserCheckedOut $userCheckedOut): Building\\State { return $state-&gt;withCheckedOutUser($userCheckedOut-&gt;name()); } public static function whenDoubleCheckOutDetected(Building\\State $state, DoubleCheckOutDetected $event): Building\\State { \/\/No state change required, simply return current state return $state; } } Building\\State should make use of the new data types as well:&lt;?php declare(strict_types=1); namespace App\\Model\\Building; use Prooph\\EventMachine\\Data\\ImmutableRecord; use Prooph\\EventMachine\\Data\\ImmutableRecordLogic; final class State implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var BuildingName *\/ private $name; \/** * @var Username[] *\/ private $users = []; private static function arrayPropItemTypeMap(): array { return ['users' =&gt; Username::class]; } \/** * Called in constructor after setting props but before not null assertion * * Override to set default props after construction *\/ private function init(): void { \/\/Build internal users map $users = []; foreach ($this-&gt;users as $username) { $users[$username-&gt;toString()] = null; } $this-&gt;users = $users; } \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return BuildingName *\/ public function name(): BuildingName { return $this-&gt;name; } \/** * @return Username[] *\/ public function users(): array { return array_map(function (string $username) { return Username::fromString($username); }, array_keys($this-&gt;users)); } public function withCheckedInUser(Username $username): State { $copy = clone $this; $copy-&gt;users[$username-&gt;toString()] = null; return $copy; } public function withCheckedOutUser(Username $username): State { if(!$this-&gt;isUserCheckedIn($username)) { return $this; } $copy = clone $this; unset($copy-&gt;users[$username-&gt;toString()]); return $copy; } public function isUserCheckedIn(Username $username): bool { return array_key_exists($username-&gt;toString(), $this-&gt;users); } } UserBuildingList projector now needs to implement the interface Prooph\\EventMachine\\Projecting\\CustomEventProjector instead of Prooph\\EventMachine\\Projecting\\Projector:src\/Infrastructure\/Projector\/UserBuildingList.php&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Projector; use App\\Api\\Event; use App\\Api\\Payload; use App\\Model\\Building\\Event\\UserCheckedIn; use App\\Model\\Building\\Event\\UserCheckedOut; use Prooph\\EventMachine\\Persistence\\DocumentStore; use Prooph\\EventMachine\\Projecting\\AggregateProjector; use Prooph\\EventMachine\\Projecting\\CustomEventProjector; final class UserBuildingList implements CustomEventProjector { \/** * @var DocumentStore *\/ private $documentStore; public function __construct(DocumentStore $documentStore) { $this-&gt;documentStore = $documentStore; } public function prepareForRun(string $appVersion, string $projectionName): void { if(!$this-&gt;documentStore-&gt;hasCollection($this-&gt;generateCollectionName($appVersion, $projectionName))) { $this-&gt;documentStore-&gt;addCollection( $this-&gt;generateCollectionName($appVersion, $projectionName) \/* Note: we could pass index configuration as a second argument, see docs for details *\/ ); } } public function handle(string $appVersion, string $projectionName, $event): void { $collection = $this-&gt;generateCollectionName($appVersion, $projectionName); switch (\\get_class($event)) { case UserCheckedIn::class: \/** @var $event UserCheckedIn *\/ $this-&gt;documentStore-&gt;addDoc( $collection, $event-&gt;name()-&gt;toString(), \/\/Use username as doc id [Payload::BUILDING_ID =&gt; $event-&gt;buildingId()-&gt;toString()] ); break; case UserCheckedOut::class: \/** @var $event UserCheckedOut *\/ $this-&gt;documentStore-&gt;deleteDoc($collection, $event-&gt;name()-&gt;toString()); break; default: \/\/Ignore unknown events } } public function deleteReadModel(string $appVersion, string $projectionName): void { $this-&gt;documentStore-&gt;dropCollection($this-&gt;generateCollectionName($appVersion, $projectionName)); } private function generateCollectionName(string $appVersion, string $projectionName): string { \/\/We can use the naming strategy of the aggregate projector for our custom projection, too return AggregateProjector::generateCollectionName($appVersion, $projectionName); } } The UiExchange event listener included in the skeleton application needs to b aligned, too. First, the corresponding interface should handle any type of event:src\/Infrastructure\/ServiceBus\/UiExchange.php&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\ServiceBus; use Prooph\\EventMachine\\Messaging\\Message; \/** * Marker Interface UiExchange * * @package App\\Infrastructure\\ServiceBus *\/ interface UiExchange { public function __invoke($event): void; } Second, an implementation of the interface should handle our event objects. The skeleton simply uses an anonymous class to implement the interface. It can be found and changed in the ServiceFactory.It's an anonymous class because the UiExchange is only included in the skeleton to demonstrate how events can be pushed to a message queue and consumed by a UI. The implementation is not meant to be used in production. You can get some inspiration from it, but please work out a production grade solution yourself.src\/Service\/ServiceFactory.php&lt;?php namespace App\\Service; \/* ... *\/ final class ServiceFactory { \/* ... *\/ public function uiExchange(): UiExchange { return $this-&gt;makeSingleton(UiExchange::class, function () { $this-&gt;assertMandatoryConfigExists('rabbit.connection'); $connection = new \\Humus\\Amqp\\Driver\\AmqpExtension\\Connection( $this-&gt;config-&gt;arrayValue('rabbit.connection') ); $connection-&gt;connect(); $channel = $connection-&gt;newChannel(); $exchange = $channel-&gt;newExchange(); $exchange-&gt;setName($this-&gt;config-&gt;stringValue('rabbit.ui_exchange', 'ui-exchange')); $exchange-&gt;setType('fanout'); $humusProducer = new \\Humus\\Amqp\\JsonProducer($exchange); $messageProducer = new \\Prooph\\ServiceBus\\Message\\HumusAmqp\\AmqpMessageProducer( $humusProducer, new class implements MessageConverter { public function convertToArray(\\Prooph\\Common\\Messaging\\Message $domainMessage): array { return [ 'uuid' =&gt; $domainMessage-&gt;uuid()-&gt;toString(), 'message_name' =&gt; $domainMessage-&gt;messageName(), 'payload' =&gt; $domainMessage-&gt;payload(), 'metadata' =&gt; $domainMessage-&gt;metadata(), 'created_at' =&gt; $domainMessage-&gt;createdAt() ]; } } ); $flavour = $this-&gt;flavour(); return new class($messageProducer, $flavour) implements UiExchange { private $producer; private $flavour; public function __construct(AmqpMessageProducer $messageProducer, Flavour $flavour) { $this-&gt;producer = $messageProducer; $this-&gt;flavour = $flavour; } public function __invoke($event): void { $messageBag = new MessageBag( Event::nameOf($event), MessageBag::TYPE_EVENT, $event ); $this-&gt;producer-&gt;__invoke($this-&gt;flavour-&gt;prepareNetworkTransmission($messageBag)); } }; }); } \/* ... *\/ } Finally, the two query resolvers should use typed queries:src\/Infrastructure\/Finder\/BuildingFinder.php&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use App\\Api\\Payload; use App\\Infrastructure\\Finder\\Query\\GetBuilding; use App\\Infrastructure\\Finder\\Query\\GetBuildings; use Prooph\\EventMachine\\Persistence\\DocumentStore; use React\\Promise\\Deferred; final class BuildingFinder { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $collectionName; public function __construct(string $collectionName, DocumentStore $documentStore) { $this-&gt;collectionName = $collectionName; $this-&gt;documentStore = $documentStore; } public function __invoke($buildingQuery, Deferred $deferred): void { switch (\\get_class($buildingQuery)) { case GetBuilding::class: \/** @var $buildingQuery GetBuilding *\/ $this-&gt;resolveBuilding($deferred, $buildingQuery-&gt;buildingId()); break; case GetBuildings::class: \/** @var $buildingQuery GetBuildings *\/ $this-&gt;resolveBuildings($deferred, $buildingQuery-&gt;name()); break; default: throw new \\InvalidArgumentException(\"Unknown query. Got \" . (is_object($buildingQuery)? get_class($buildingQuery) : gettype($buildingQuery)) ); } } private function resolveBuilding(Deferred $deferred, string $buildingId): void { $buildingDoc = $this-&gt;documentStore-&gt;getDoc($this-&gt;collectionName, $buildingId); if(!$buildingDoc) { $deferred-&gt;reject(new \\RuntimeException('Building not found', 404)); return; } $deferred-&gt;resolve($buildingDoc); } private function resolveBuildings(Deferred $deferred, string $nameFilter = null): array { $filter = $nameFilter? new DocumentStore\\Filter\\LikeFilter(Payload::NAME, \"%$nameFilter%\") : new DocumentStore\\Filter\\AnyFilter(); $cursor = $this-&gt;documentStore-&gt;filterDocs($this-&gt;collectionName, $filter); $deferred-&gt;resolve(iterator_to_array($cursor)); } } You might have noticed that the queries don't use value objects like commands or events. That's because we don't want to couple the read model with the write model that much. Simple scalar types are usually enough for queries. Validation is done by Json Schema anyway.src\/Infrastructure\/Finder\/UserBuildingFinder.phhp&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Finder; use App\\Api\\Payload; use App\\Infrastructure\\Finder\\Query\\GetUserBuildingList; use Prooph\\EventMachine\\Persistence\\DocumentStore; use React\\Promise\\Deferred; final class UserBuildingFinder { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $userBuildingCollection; \/** * @var string *\/ private $buildingCollection; public function __construct(DocumentStore $documentStore, string $userBuildingCol, string $buildingCol) { $this-&gt;documentStore = $documentStore; $this-&gt;userBuildingCollection = $userBuildingCol; $this-&gt;buildingCollection = $buildingCol; } public function __invoke(GetUserBuildingList $query, Deferred $deferred): void { $userBuilding = $this-&gt;documentStore-&gt;getDoc( $this-&gt;userBuildingCollection, $query-&gt;name() ); if(!$userBuilding) { $deferred-&gt;resolve([ 'user' =&gt; $query-&gt;name(), 'building' =&gt; null ]); return; } $building = $this-&gt;documentStore-&gt;getDoc( $this-&gt;buildingCollection, $userBuilding['buildingId'] ); if(!$building) { $deferred-&gt;resolve([ 'user' =&gt; $query-&gt;name(), 'building' =&gt; null ]); return; } $deferred-&gt;resolve([ 'user' =&gt; $query-&gt;name(), 'building' =&gt; $building ]); return; } } That's it! You can use the Swagger UI to test changes.Or wait! We did not run the tests!docker-compose run php php vendor\/bin\/phpunit Doesn't look good, right? Let's fix them!The skeleton provides a BaseTestCase and in its setUp method we can change the Flavour used during testing.&lt;?php declare(strict_types=1); namespace AppTest; use App\\Infrastructure\\Flavour\\AppMessagePort; use PHPUnit\\Framework\\TestCase; use Prooph\\EventMachine\\Container\\ContainerChain; use Prooph\\EventMachine\\Container\\EventMachineContainer; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Runtime\\FunctionalFlavour; class BaseTestCase extends TestCase { \/** * @var EventMachine *\/ protected $eventMachine; \/** * @var Flavour *\/ protected $flavour; protected function setUp() { $this-&gt;eventMachine = new EventMachine(); $this-&gt;flavour = new FunctionalFlavour(new AppMessagePort()); $config = include __DIR__ . '\/..\/config\/autoload\/global.php'; foreach ($config['event_machine']['descriptions'] as $description) { $this-&gt;eventMachine-&gt;load($description); } $this-&gt;eventMachine-&gt;initialize( new ContainerChain( new FlavourContainer($this-&gt;flavour), new EventMachineContainer($this-&gt;eventMachine) ) ); } \/* ... *\/ } The assertRecordedEvent method needs an adjustment, too:&lt;?php declare(strict_types=1); namespace AppTest; use App\\Infrastructure\\Flavour\\AppMessagePort; use PHPUnit\\Framework\\TestCase; use Prooph\\EventMachine\\Container\\ContainerChain; use Prooph\\EventMachine\\Container\\EventMachineContainer; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Runtime\\FunctionalFlavour; class BaseTestCase extends TestCase { \/** * @var EventMachine *\/ protected $eventMachine; \/** * @var Flavour *\/ protected $flavour; \/* ... *\/ protected function assertRecordedEvent(string $eventName, array $payload, array $events, $assertNotRecorded = false): void { $isRecorded = false; foreach ($events as $evt) { if($evt === null) { continue; } \/\/Convert domain events to raw data $evtName = Event::nameOf($evt); $evtPayload = $evt-&gt;toArray(); if($eventName === $evtName) { $isRecorded = true; if(!$assertNotRecorded) { $this-&gt;assertEquals($payload, $evtPayload, \"Payload of recorded event $evtName does not match with expected payload.\"); } } } if($assertNotRecorded) { $this-&gt;assertFalse($isRecorded, \"Event $eventName is recorded\"); } else { $this-&gt;assertTrue($isRecorded, \"Event $eventName is not recorded\"); } } } NotifySecurityTest contains a mocked UiExchange. We changed the interface earlier, but did not change the mock. The test itself needs minor adjustments, too.tests\/Integration\/NotifySecurityTest.php&lt;?php declare(strict_types=1); namespace AppTest\\Integration; use App\\Api\\Command; use App\\Api\\Event; use App\\Api\\Payload; use App\\Infrastructure\\ServiceBus\\UiExchange; use AppTest\\BaseTestCase; final class NotifySecurityTest extends BaseTestCase { const BUILDING_ID = '7c5f0c8a-54f2-4969-9596-b5bddc1e9421'; const BUILDING_NAME = 'Acme Headquarters'; const USERNAME = 'John'; private $uiExchange; protected function setUp() { \/\/The BaseTestCase loads all Event Machine descriptions configured in config\/autoload\/global.php parent::setUp(); \/\/Mock UiExchange with an anonymous class that keeps track of the last received message $this-&gt;uiExchange = new class implements UiExchange { private $lastReceivedMessage; public function __invoke($event): void { $this-&gt;lastReceivedMessage = $event; } public function lastReceivedMessage() { return $this-&gt;lastReceivedMessage; } }; } \/** * @test *\/ public function it_detects_double_check_in_and_notifies_security() { $this-&gt;eventMachine-&gt;bootstrapInTestMode( \/\/Add history events that should have been recorded before current test scenario [ $this-&gt;message(Event::BUILDING_ADDED, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::BUILDING_NAME ]), $this-&gt;message(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ]), ], \/\/Provide mocked services used in current test scenario, if you forget one the test will throw an exception \/\/You don't have to mock the event store and document store, that is done internally [ \/\/Remember, UiExchange is our process manager that pushes events to rabbit \/\/Event Machine is configured to push DoubleCheckInDetected events on to UiExchange (src\/Api\/Listener.php) UiExchange::class =&gt; $this-&gt;uiExchange ] ); \/\/Try to check in John twice $checkInJohn = $this-&gt;message(Command::CHECK_IN_USER, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ]); $this-&gt;eventMachine-&gt;dispatch($checkInJohn); \/\/After dispatch $this-&gt;lastPublishedEvent points to the event received by UiExchange mock $this-&gt;assertNotNull($this-&gt;uiExchange-&gt;lastReceivedMessage()); $this-&gt;assertEquals(Event::DOUBLE_CHECK_IN_DETECTED, Event::nameOf($this-&gt;uiExchange-&gt;lastReceivedMessage())); $this-&gt;assertEquals([ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ], $this-&gt;uiExchange-&gt;lastReceivedMessage()-&gt;toArray()); } } Next on the list is BuildingTest. It breaks because we introduced types for building state properties. That's going to be an easy fix.tests\/Model\/BuildingTest.php&lt;?php declare(strict_types=1); namespace AppTest\\Model; use App\\Api\\Event; use App\\Api\\Payload; use AppTest\\BaseTestCase; use Ramsey\\Uuid\\Uuid; use App\\Model\\Building; class BuildingTest extends BaseTestCase { \/* ... *\/ \/** * @test *\/ public function it_detects_double_check_in() { \/* ... *\/ $state = $state-&gt;withCheckedInUser(Building\\Username::fromString($this-&gt;username)); \/* ... *\/ } } And last adjustments in UserBuildingListTest::it_manages_list_of_users_with_building_reference(). The projector expects dedicated event objects now.tests\/Infrastructure\/Projector\/UserBuildingListTest.php&lt;?php declare(strict_types=1); namespace AppTest\\Infrastructure\\Projector; use App\\Api\\Payload; use App\\Infrastructure\\Projector\\UserBuildingList; use App\\Model\\Building\\Event\\UserCheckedIn; use App\\Model\\Building\\Event\\UserCheckedOut; use AppTest\\BaseTestCase; use Prooph\\EventMachine\\Persistence\\DocumentStore; use Prooph\\EventMachine\\Persistence\\InMemoryConnection; use Prooph\\EventMachine\\Projecting\\AggregateProjector; final class UserBuildingListTest extends BaseTestCase { const APP_VERSION = '0.1.0'; const PROJECTION_NAME = 'user_building_list'; const BUILDING_ID = '7c5f0c8a-54f2-4969-9596-b5bddc1e9421'; const USERNAME1 = 'John'; const USERNAME2 = 'Jane'; \/** * @var DocumentStore *\/ private $documentStore; \/** * @var UserBuildingList *\/ private $projector; protected function setUp() { parent::setUp(); $this-&gt;documentStore = new DocumentStore\\InMemoryDocumentStore(new InMemoryConnection()); $this-&gt;projector = new UserBuildingList($this-&gt;documentStore); $this-&gt;projector-&gt;prepareForRun(self::APP_VERSION, self::PROJECTION_NAME); } \/** * @test *\/ public function it_manages_list_of_users_with_building_reference() { $collection = AggregateProjector::generateCollectionName(self::APP_VERSION, self::PROJECTION_NAME); $johnCheckedIn = UserCheckedIn::fromArray([ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME1 ]); $this-&gt;projector-&gt;handle(self::APP_VERSION, self::PROJECTION_NAME, $johnCheckedIn); $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs($collection, new DocumentStore\\Filter\\AnyFilter())); $this-&gt;assertEquals($users, [ 'John' =&gt; ['buildingId' =&gt; self::BUILDING_ID] ]); $janeCheckedIn = UserCheckedIn::fromArray([ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME2 ]); $this-&gt;projector-&gt;handle(self::APP_VERSION, self::PROJECTION_NAME, $janeCheckedIn); $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs($collection, new DocumentStore\\Filter\\AnyFilter())); $this-&gt;assertEquals($users, [ 'John' =&gt; ['buildingId' =&gt; self::BUILDING_ID], 'Jane' =&gt; ['buildingId' =&gt; self::BUILDING_ID], ]); $johnCheckedOut = UserCheckedOut::fromArray([ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME1 ]); $this-&gt;projector-&gt;handle(self::APP_VERSION, self::PROJECTION_NAME, $johnCheckedOut); $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs($collection, new DocumentStore\\Filter\\AnyFilter())); $this-&gt;assertEquals($users, [ 'Jane' =&gt; ['buildingId' =&gt; self::BUILDING_ID], ]); } } Tests are green again. Refactoring finished successfully. Was it worth the effort? Switching the Flavour is quite some workt to do, isn't it? Depending on the amount of already written code and tests this task can take some days and you need to make sure that you don't break existing functionality. On the other hand you get a fully decoupled domain model. Of course, it's also possible to use another Flavour right from the beginning. But keep in mind, that the PrototypingFlavour saves a lot of time in the early days of a project. You don't know if the first app version really meets business and user needs. You can only try and experiment. The faster you have a working app, the faster you can get feedback from users and stakeholders. A lean implementation and simple infrastructure gives you a lot of flexibility at the beginning. Starting with a MVP is not a new concept. Event Machine just gives you a nice tool to build one and reuse parts of your experiments in later project phases. Also using CQRS \/ ES from day one gives you full advantage of a reactive system.Still curious to see what the OopFlavour can do? The last bonus part sheds light on it."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12","title":"Bonus IV - OOP Flavour","content":"The previous bonus part introduced Event Machine Flavours, especially the FunctionalFlavour. Biggest change was the replacement of generic Event Machine messages with dedicated message types."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-1","title":"Original Object-Oriented Programming","content":"Event Machine emphasizes the usage of a functional core. That's true for the PrototypingFlavour and unfolds completely with the FunctionalFlavour. A functional core has huge advantages compared to its object-oriented counterpart. At least compared to the way we tend to work with objects in our projects the last twenty years or so.Dr. Alan Kay (who has coined the term) had quite a different idea of object-oriented programming back in 1967. I thought of objects being like biological cells and\/or individual computers on a network, only able to communicate with messages sourceLet that sink in - only able to communicate with messages.If you look at what we've built so far, you might recognize that we are very close to that statement. Finder\/Resolver, Event Listener, Process Manager and Projector all are invoked with messages. They don't interact with each other directly. Event Machine takes over coordination. It's like the network Alan Kay is talking about. But what about aggregate functions? The functions are stateless and don't have side effects. They are pure. Immutable data types and messages (commands or events) are passed to them. With coordination performed by Event Machine pure functions work great."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-2","title":"It Is Not Functional Programming","content":"We are not used to work with pure functions in PHP. It's not a functional programming language, right? Autoloading functions doesn't work so we are either forced to require all files manually or use the workaround shown in the tutorial to turn pure functions into static methods of otherwise useless classes.Personally, I don't have a big problem with the latter approach. I see those classes as the last part of the namespace or even similar to an ES6 module (if you're familiar with JavaScript). The module (PHP class) can export functions (public static functions) and use internal functions (private static functions). But I have to admit that it is a workaround."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-3","title":"OopFlavour on top of FunctionalFlavour","content":"What can we do if the workaround is not acceptable for a project or personal taste? Exactly, we can pick another Flavour :DThe OopFlavour in a nutshell:Aggregate functions (command handling and apply functions) are combined with state into one object. Each aggregate manages its own state internally. Commands trigger state changes. A state change is first recorded as an event and then applied by the aggregate.You know what this means, right? I thought of objects being like biological cells and\/or individual computers on a network, only able to communicate with messages As I said, we're very close to that statement. That's the reason why the OopFlavour uses the FunctionalFlavour internally. It works on top of it only to combine aggregate functions and state. More on that in a minute. First we need a solid foundation for event sourced objects."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-4","title":"OOP Port","content":"Similar to the Functional\\Port we need to implement an Oop\\Port to use the OopFlavour. Let's start again by looking at the required methods. Create a new class EventSourcedAggregatePort in src\/Infrastructure\/Flavour:&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Flavour; use Prooph\\EventMachine\\Runtime\\Oop\\Port; final class EventSourcedAggregatePort implements Port { \/** * @param string $aggregateType * @param callable $aggregateFactory * @param $customCommand * @param null|mixed $context * @return mixed Created aggregate *\/ public function callAggregateFactory(string $aggregateType, callable $aggregateFactory, $customCommand, $context = null) { \/\/ TODO: Implement callAggregateFactory() method. } \/** * @param mixed $aggregate * @param mixed $customCommand * @param null|mixed $context *\/ public function callAggregateWithCommand($aggregate, $customCommand, $context = null): void { \/\/ TODO: Implement callAggregateWithCommand() method. } \/** * @param mixed $aggregate * @return array of custom events *\/ public function popRecordedEvents($aggregate): array { \/\/ TODO: Implement popRecordedEvents() method. } \/** * @param mixed $aggregate * @param mixed $customEvent *\/ public function applyEvent($aggregate, $customEvent): void { \/\/ TODO: Implement applyEvent() method. } \/** * @param mixed $aggregate * @return array *\/ public function serializeAggregate($aggregate): array { \/\/ TODO: Implement serializeAggregate() method. } \/** * @param string $aggregateType * @param iterable $events history * @return mixed Aggregate instance *\/ public function reconstituteAggregate(string $aggregateType, iterable $events) { \/\/ TODO: Implement reconstituteAggregate() method. } } This time we don't work top to bottom but start in the middle. popRecordedEvents and applyEvent are the first targets.Same basic rules apply here as we discussed for the Functional\\Port. Event Machine does not require a specific strategy to work with event sourced aggregates. You can implement them in any way as long as the Oop\\Port is able to fulfill the contract. That said, the approach shown in the tutorial is just a suggestion. We're going to use a simple and pragmatic implementation with publicly accessible methods that are actually internal methods. You might want to hide them in your project using a decorator or PHP's Reflection API. Anyway, that would be overkill for the tutorial."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-5","title":"Event Sourced Aggregate Root","content":"A state change is first recorded as an event and then applied by the aggregate.Let's create an interface for the port to rely on:src\/Model\/Base\/AggregateRoot.php&lt;?php declare(strict_types=1); namespace App\\Model\\Base; interface AggregateRoot { \/** * @return DomainEvent[] *\/ public function popRecordedEvents(): array; public function apply(DomainEvent $event): void; } We don't have a DomainEvent type yet. Add it next to the AggregateRoot interface in the same directory.src\/Model\/Base\/DomainEvent.php&lt;?php declare(strict_types=1); namespace App\\Model\\Base; interface DomainEvent { \/\/Marker interface } With those two interfaces we can implement the first methods of the Oop\\Port:src\/Infrastructure\/Flavour\/EventSourcedAggregatePort.php&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Flavour; use App\\Model\\Base\\AggregateRoot; use Prooph\\EventMachine\\Runtime\\Oop\\Port; final class EventSourcedAggregatePort implements Port { \/* ... *\/ \/** * @param mixed $aggregate * @return array of custom events *\/ public function popRecordedEvents($aggregate): array { if(!$aggregate instanceof AggregateRoot) { throw new \\RuntimeException( sprintf(\"Cannot pop recorded events. Given aggregate is not an instance of %s. Got %s\", AggregateRoot::class, (is_object($aggregate)? get_class($aggregate) : gettype($aggregate)) ) ); } return $aggregate-&gt;popRecordedEvents(); } \/** * @param mixed $aggregate * @param mixed $customEvent *\/ public function applyEvent($aggregate, $customEvent): void { if(!$aggregate instanceof AggregateRoot) { throw new \\RuntimeException( sprintf(\"Cannot apply event. Given aggregate is not an instance of %s. Got %s\", AggregateRoot::class, (is_object($aggregate)? get_class($aggregate) : gettype($aggregate)) ) ); } $aggregate-&gt;apply($customEvent); } \/* ... *\/ } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-6","title":"Aggregate Root Lifecycle","content":"Next two methods we are looking at are callAggregateFactory and reconstituteAggregate. The former starts the lifecycle of a new aggregate and the latter brings it back into shape by passing aggregate event history (all events previously recorded by the aggregate) to the method.Traits are a great way to reuse code snippets without inheritance. It's like copy and pasting methods from a blueprint into a class. Let's define one for common event sourcing logic that we can later use in aggregates.src\/Model\/Base\/EventSourced.php&lt;?php declare(strict_types=1); namespace App\\Model\\Base; trait EventSourced { \/** * @var DomainEvent[] *\/ private $recordedEvents = []; \/** * @param DomainEvent[] $domainEvents * @return EventSourced aggregate *\/ public static function reconstituteFromHistory(DomainEvent ...$domainEvents): AggregateRoot { $self = new self(); foreach ($domainEvents as $domainEvent) { $self-&gt;apply($domainEvent); } return $self; } private function __construct() { \/\/Do not override this!!!! \/\/Use named constructors aka public static factory methods to create aggregae instances! } private function recordThat(DomainEvent $event): void { $this-&gt;recordedEvents[] = $event; } \/** * @return DomainEvent[] *\/ public function popRecordedEvents(): array { $events = $this-&gt;recordedEvents; $this-&gt;recordedEvents = []; return $events; } public function apply(DomainEvent $event): void { $whenMethod = $this-&gt;deriveMethodNameFromEvent($event); if(!method_exists($this, $whenMethod)) { throw new \\RuntimeException(\\sprintf( \"Unable to apply event %s. Missing method %s in class %s\", \\get_class($event), $whenMethod, \\get_class($this) )); } $this-&gt;{$whenMethod}($event); } private function deriveMethodNameFromEvent(DomainEvent $event): string { $nameParts = \\explode('\\\\', \\get_class($event)); return 'when' . \\array_pop($nameParts); } } The trait provides implementations for popRecordedEvents and apply defined by AggregateRoot. But it contains some more stuff!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-6-1","title":"Derive Method Name From Event","content":"A convention is used that says: An aggregate should have an apply method for each domain event following the naming pattern \"when&lt;EventName&gt;\", whereby &lt;EventName&gt; is the class name of the event without namespace."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-6-2","title":"Record That","content":"An aggregate should use recordThat to record new domain events. The trait takes care of storing recorded events internally until the Oop\\Port calls popRecordedEvents()."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-6-3","title":"Private Empty Constructor","content":"While a trait cannot enforce a private empty __construct (it could be overridden by a class), it's still included in the trait as a reminder for future developers to not use __construct in aggregate roots but rather use named constructors. This rule is important for Oop\\Port::callAggregateFactory(). More on that in a minute."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-6-4","title":"Reconstitute From History","content":"reconstituteFromHistory should be called by the Oop\\Port. But the port works against our AggregateRoot interface, so we should add such a method signature there, too.src\/Model\/Base\/AggregateRoot.php&lt;?php declare(strict_types=1); namespace App\\Model\\Base; interface AggregateRoot { public static function reconstituteFromHistory(DomainEvent ...$domainEvents): self; \/** * @return DomainEvent[] *\/ public function popRecordedEvents(): array; public function apply(DomainEvent $event): void; } Cool, we can implement the next port method now!src\/Infrastructure\/Flavour\/EventSourcedAggregatePort.php&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Flavour; use App\\Model\\Base\\AggregateRoot; use Prooph\\EventMachine\\Runtime\\Oop\\Port; final class EventSourcedAggregatePort implements Port { \/* ... *\/ \/** * @param string $aggregateType * @param iterable $events history * @return mixed Aggregate instance *\/ public function reconstituteAggregate(string $aggregateType, iterable $events) { $arClass = $this-&gt;getAggregateClassOfType($aggregateType); \/** @var AggregateRoot $arClass *\/ return $arClass::reconstituteFromHistory(...$events); } private function getAggregateClassOfType(string $aggregateType): string { switch ($aggregateType) { case Aggregate::BUILDING: return Building::class; default: throw new \\RuntimeException(\"Unknown aggregate type $aggregateType\"); } } } Obviously, this won't work. We did not touch Building yet. Let's do that next."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-7","title":"Merge Functions And State","content":"Our Building aggregate consists of a set of pure functions grouped in a class and immutable data types. Turning it into an event sourced object is less work than you might expect:src\/Model\/Building.php&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Model\\Base\\AggregateRoot; use App\\Model\\Base\\EventSourced; use App\\Model\\Building\\Command\\AddBuilding; use App\\Model\\Building\\Command\\CheckInUser; use App\\Model\\Building\\Command\\CheckOutUser; use App\\Model\\Building\\Event\\BuildingAdded; use App\\Model\\Building\\Event\\DoubleCheckInDetected; use App\\Model\\Building\\Event\\DoubleCheckOutDetected; use App\\Model\\Building\\Event\\UserCheckedIn; use App\\Model\\Building\\Event\\UserCheckedOut; final class Building implements AggregateRoot { use EventSourced; \/** * @var Building\\State *\/ private $state; public static function add(AddBuilding $addBuilding): AggregateRoot { $self = new self(); $self-&gt;recordThat(BuildingAdded::fromArray($addBuilding-&gt;toArray())); return $self; } public function whenBuildingAdded(BuildingAdded $buildingAdded): void { $this-&gt;state = Building\\State::fromArray($buildingAdded-&gt;toArray()); } public function checkInUser(CheckInUser $checkInUser): void { if($this-&gt;state-&gt;isUserCheckedIn($checkInUser-&gt;name())) { $this-&gt;recordThat(DoubleCheckInDetected::fromArray($checkInUser-&gt;toArray())); return; } $this-&gt;recordThat(UserCheckedIn::fromArray($checkInUser-&gt;toArray())); } private function whenUserCheckedIn(UserCheckedIn $userCheckedIn): void { $this-&gt;state = $this-&gt;state-&gt;withCheckedInUser($userCheckedIn-&gt;name()); } private function whenDoubleCheckInDetected(DoubleCheckInDetected $event): void { \/\/No state change required } public function checkOutUser(CheckOutUser $checkOutUser): void { if(!$this-&gt;state-&gt;isUserCheckedIn($checkOutUser-&gt;name())) { $this-&gt;recordThat(DoubleCheckOutDetected::fromArray($checkOutUser-&gt;toArray())); return; } $this-&gt;recordThat(UserCheckedOut::fromArray($checkOutUser-&gt;toArray())); } private function whenUserCheckedOut(UserCheckedOut $userCheckedOut): void { $this-&gt;state = $this-&gt;state-&gt;withCheckedOutUser($userCheckedOut-&gt;name()); } private function whenDoubleCheckOutDetected(DoubleCheckOutDetected $event): void { \/\/No state change required } } Here are the refactoring steps: All events need to implement App\\Model\\Base\\DomainEvent Building implements AggregateRoot Building uses EventSourced Building stores Building\\State internally in a state property Building::add() creates an instance of itself and records BuildingAdded instead of yielding it All other command handling functions: Remove static, they become instance methods Change return type to void Building\\State is no longer an argument, but accessed internally Domain events get recorded All apply\/when functions Remove static and make them private, they become internal methods Change return type to void Building\\State is no longer an argument, but accessed internally "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-8","title":"Aggregate Factory","content":"Building::add() is the aggregate factory for Building. The Oop\\Port can simply call it.src\/Infrastructure\/Flavour\/EventSourcedAggregatePort.php&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Flavour; use App\\Model\\Base\\AggregateRoot; use Prooph\\EventMachine\\Runtime\\Oop\\Port; final class EventSourcedAggregatePort implements Port { \/** * @param string $aggregateType * @param callable $aggregateFactory * @param $customCommand * @param null|mixed $context * @return mixed Created aggregate *\/ public function callAggregateFactory(string $aggregateType, callable $aggregateFactory, $customCommand, $context = null) { return $aggregateFactory($customCommand, $context); } \/* ... *\/ } The callable $aggregateFactory passed to the port, is still the one we've defined in the Event Machine Description:src\/Api\/Aggregate.php&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy(Payload::BUILDING_ID) -&gt;handle([Building::class, 'add']) \/\/&lt;-- Aggregate Factory -&gt;recordThat(Event::BUILDING_ADDED) -&gt;apply([Building::class, 'whenBuildingAdded']); \/* ... *\/ } } $context is not an argument of Building::add() but PHP does not care. We can use that to our advantage. The port does not need to know if an aggregate factory or command handling function is interested in a context or not. It just passes it always to the function. If context is null and the function doesn't care, everything is fine."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-9","title":"Command Handling","content":"Oop\\Port::callAggregateWithCommand() is next on the list. Let's see ...\/** * @param mixed $aggregate * @param mixed $customCommand * @param null|mixed $context *\/ public function callAggregateWithCommand($aggregate, $customCommand, $context = null): void { \/\/ TODO: Implement callAggregateWithCommand() method. } We get the $aggregate instance, a $customCommand and optionally a $context. We could use a switch (command) -&gt; call $aggregate-&gt;method approach, but we are lazy. We don't want to touch the port each time we add a new command to the system. Conventions work great to get around the issue.An aggregate root should have a method named like the command, whereby command name is derived from its class name without namespace. The first letter of the name is lowercase.Looking at Building methods, it's exactly what we already have in place ;) We just need to implement the convention in the port.src\/Infrastructure\/Flavour\/EventSourcedAggregatePort.php&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Flavour; use App\\Model\\Base\\AggregateRoot; use Prooph\\EventMachine\\Runtime\\Oop\\Port; final class EventSourcedAggregatePort implements Port { \/* ... *\/ \/** * @param mixed $aggregate * @param mixed $customCommand * @param null|mixed $context *\/ public function callAggregateWithCommand($aggregate, $customCommand, $context = null): void { $commandNameParts = \\explode('\\\\', \\get_class($customCommand)); $handlingMethod = \\lcfirst(\\array_pop($commandNameParts)); $aggregate-&gt;{$handlingMethod}($customCommand, $context); } \/* ... *\/ } Low hanging fruits, right? But the Event Machine Aggregate Description is broken! Handle and apply functions are no longer callable (except aggregate factory), because they are instance methods now. To get around the issue, we can replace the definition with a FlavourHint.src\/Api\/Aggregate.php&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Model\\Building; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\Runtime\\Oop\\FlavourHint; class Aggregate implements EventMachineDescription { const BUILDING = 'Building'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy(Payload::BUILDING_ID) -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED) -&gt;apply([FlavourHint::class, 'useAggregate']); $eventMachine-&gt;process(Command::CHECK_IN_USER) -&gt;withExisting(self::BUILDING) -&gt;handle([FlavourHint::class, 'useAggregate']) -&gt;recordThat(Event::USER_CHECKED_IN) -&gt;apply([FlavourHint::class, 'useAggregate']) -&gt;orRecordThat(Event::DOUBLE_CHECK_IN_DETECTED) -&gt;apply([FlavourHint::class, 'useAggregate']); $eventMachine-&gt;process(Command::CHECK_OUT_USER) -&gt;withExisting(self::BUILDING) -&gt;handle([FlavourHint::class, 'useAggregate']) -&gt;recordThat(Event::USER_CHECKED_OUT) -&gt;apply([FlavourHint::class, 'useAggregate']) -&gt;orRecordThat(Event::DOUBLE_CHECK_OUT_DETECTED) -&gt;apply([FlavourHint::class, 'useAggregate']); } } That's a bit of a drawback of the OopFlavour. It relies less on Event Machine, but Event Machine still wants to make sure that you don't forget to handle a command or apply an event (handle and apply definition is mandatory). With the FlavourHint we basically tell Event Machine: \"Don't worry, we know what we're doing!\". It's a small extra step, but trust me, it still saves you time. Forgetting to add a route for a message to some config or have a typo somewhere is one of the most silly bugs that can cost you hours for nothing!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-10","title":"Aggregate State","content":"One method left in the port: serializeAggregate(). This method is only important when using aggregate projections. Let's check the Projection Description:src\/Api\/Projecion.php&lt;?php declare(strict_types=1); namespace App\\Api; use App\\Infrastructure\\Projector\\UserBuildingList; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\Persistence\\Stream; class Projection implements EventMachineDescription { const USER_BUILDING_LIST = 'user_building_list'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;watch(Stream::ofWriteModel()) -&gt;withAggregateProjection(Aggregate::BUILDING); $eventMachine-&gt;watch(Stream::ofWriteModel()) -&gt;with(self::USER_BUILDING_LIST, UserBuildingList::class) -&gt;filterEvents([ Event::USER_CHECKED_IN, Event::USER_CHECKED_OUT, ]); } } Ok, we do use it, so we have to implement the port method, otherwise we could throw a \\BadMethodCallException and are done.A word about aggregate projection: It's a default projection provided by Event Machine for rapid application development. With an aggregate projection you can get very close to RAD frameworks that work with relational databases and an ORM. The main difference is, with Event Machine you use CQRS \/ ES from the beginning. However, using aggregate state as a read model couples the aggregate with read concerns. It cannot simply change its internal state without the risk of breaking a query. The good news is, that you can remove that coupling at any point in time by turning an aggregae projection into a dedicated projection like the USER_BUILDING_LIST projection. You can start simple, but make a cut whenever things start to look messy.A simple toArray() on the aggregate is sufficient. We add it to the AggregateRoot interface to enforce its implementation.src\/Model\/Base\/AggregateRoot.php&lt;?php declare(strict_types=1); namespace App\\Model\\Base; interface AggregateRoot { \/** * @return DomainEvent[] *\/ public function popRecordedEvents(): array; public function apply(DomainEvent $event): void; public function toArray(): array; } Building can call the toArray method of Building\\State ...src\/Model\/Building.php&lt;?php declare(strict_types=1); namespace App\\Model; use App\\Model\\Base\\AggregateRoot; use App\\Model\\Base\\EventSourced; use App\\Model\\Building\\Command\\AddBuilding; use App\\Model\\Building\\Command\\CheckInUser; use App\\Model\\Building\\Command\\CheckOutUser; use App\\Model\\Building\\Event\\BuildingAdded; use App\\Model\\Building\\Event\\DoubleCheckInDetected; use App\\Model\\Building\\Event\\DoubleCheckOutDetected; use App\\Model\\Building\\Event\\UserCheckedIn; use App\\Model\\Building\\Event\\UserCheckedOut; final class Building implements AggregateRoot { use EventSourced; \/** * @var Building\\State *\/ private $state; \/* ... *\/ public function toArray(): array { return $this-&gt;state-&gt;toArray(); } } ... and the Oop\\Port does the same:src\/Infrastructure\/Flavour\/EventSourcedAggregatePort.php&lt;?php declare(strict_types=1); namespace App\\Infrastructure\\Flavour; use App\\Model\\Base\\AggregateRoot; use Prooph\\EventMachine\\Runtime\\Oop\\Port; final class EventSourcedAggregatePort implements Port { \/* ... *\/ \/** * @param mixed $aggregate * @return array *\/ public function serializeAggregate($aggregate): array { if(!$aggregate instanceof AggregateRoot) { throw new \\RuntimeException( sprintf(\"Cannot serialize aggregate. Given aggregate is not an instance of %s. Got %s\", AggregateRoot::class, (is_object($aggregate)? get_class($aggregate) : gettype($aggregate)) ) ); } return $aggregate-&gt;toArray(); } \/* ... *\/ } Of course, you can use a totally different serialization strategy. Organising aggregate state in a single immutable state object is also only a suggestion. Do whatever you like or don't use aggregate projections at all and don't implement the functionality. It's your choice!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-11","title":"Activate OopFlavour","content":"As a last step (before looking at the tests \u00f0\u009f\u0099\u0088) we should activate the OopFlavour in the ServiceFactory:src\/Service\/ServiceFactory.php&lt;?php namespace App\\Service; use App\\Infrastructure\\Flavour\\AppMessagePort; use Prooph\\EventMachine\\Runtime\\Flavour; use Prooph\\EventMachine\\Runtime\\FunctionalFlavour; \/* ... *\/ final class ServiceFactory { use ServiceRegistry; \/** * @var ArrayReader *\/ private $config; \/** * @var ContainerInterface *\/ private $container; public function __construct(array $appConfig) { $this-&gt;config = new ArrayReader($appConfig); } public function setContainer(ContainerInterface $container): void { $this-&gt;container = $container; } \/\/Flavour public function flavour(): Flavour { return $this-&gt;makeSingleton(Flavour::class, function () { return new OopFlavour( new EventSourcedAggregatePort(), new FunctionalFlavour(new AppMessagePort()) ); }); } \/* ... *\/ } As stated at the beginning, the OopFlavour uses the FunctionalFlavour mainly to make use of custom message handling."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-12","title":"Fixing tests","content":"At least the BuildingTest should fail after latest changes. Let's see if we need to work some extra hours or can go out to have a beer with a friend:docker-compose run php php vendor\/bin\/phpunit As expected, BuildingTest is broken, but should be easy to fix. First, we need to change the Flavour in the test suite as well.tests\/BaseTestCase.php&lt;?php declare(strict_types=1); namespace AppTest; use App\\Api\\Event; use App\\Infrastructure\\Flavour\\AppMessagePort; use App\\Infrastructure\\Flavour\\EventSourcedAggregatePort; use App\\Model\\Base\\AggregateRoot; use App\\Model\\Base\\DomainEvent; use PHPUnit\\Framework\\TestCase; use Prooph\\EventMachine\\Container\\ContainerChain; use Prooph\\EventMachine\\Container\\EventMachineContainer; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\Messaging\\Message; use Prooph\\EventMachine\\Messaging\\MessageBag; use Prooph\\EventMachine\\Runtime\\Flavour; use Prooph\\EventMachine\\Runtime\\FunctionalFlavour; use Prooph\\EventMachine\\Runtime\\Oop\\FlavourHint; use Prooph\\EventMachine\\Runtime\\OopFlavour; class BaseTestCase extends TestCase { \/** * @var EventMachine *\/ protected $eventMachine; \/** * @var Flavour *\/ protected $flavour; protected function setUp() { $this-&gt;eventMachine = new EventMachine(); $this-&gt;flavour = new OopFlavour( new EventSourcedAggregatePort(), new FunctionalFlavour(new AppMessagePort()) ); $config = include __DIR__ . '\/..\/config\/autoload\/global.php'; foreach ($config['event_machine']['descriptions'] as $description) { $this-&gt;eventMachine-&gt;load($description); } $this-&gt;eventMachine-&gt;initialize( new ContainerChain( new FlavourContainer($this-&gt;flavour), new EventMachineContainer($this-&gt;eventMachine) ) ); } \/* ... *\/ protected function applyEvents(AggregateRoot $aggregateRoot) { array_walk($aggregateRoot-&gt;popRecordedEvents(), function (DomainEvent $event) use ($aggregateRoot) { $this-&gt;flavour-&gt;callApplySubsequentEvent( [FlavourHint::class, 'useAggregate'], $aggregateRoot, new MessageBag( Event::nameOf($event), MessageBag::TYPE_EVENT, $event ) ); }); } } With a little test helper applyEvents we can use the Flavour to apply recorded events.When testing event sourced objects we cannot simply prepare state and call a function. We have to invoke all command handling functions needed to get the aggregate into desired state. That's the change we have to make in BuildingTest:&lt;?php declare(strict_types=1); namespace AppTest\\Model; use App\\Api\\Event; use App\\Api\\Payload; use AppTest\\BaseTestCase; use Ramsey\\Uuid\\Uuid; use App\\Model\\Building; class BuildingTest extends BaseTestCase { private $buildingId; private $buildingName; private $username; protected function setUp() { $this-&gt;buildingId = Uuid::uuid4()-&gt;toString(); $this-&gt;buildingName = 'Acme Headquarters'; $this-&gt;username = 'John'; parent::setUp(); } \/** * @test *\/ public function it_checks_in_a_user() { \/\/Prepare expected aggregate state $addBuilding = Building\\Command\\AddBuilding::fromArray([ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;buildingName ]); \/** @var Building $building *\/ $building = Building::add($addBuilding); \/\/New test helper to apply recorded events $this-&gt;applyEvents($building); $command = Building\\Command\\CheckInUser::fromArray([ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username, ]); $building-&gt;checkInUser($command); $events = $building-&gt;popRecordedEvents(); $this-&gt;assertRecordedEvent(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username ], $events); } \/** * @test *\/ public function it_detects_double_check_in() { \/\/Prepare expected aggregate state $addBuilding = Building\\Command\\AddBuilding::fromArray([ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;buildingName ]); \/** @var Building $building *\/ $building = Building::add($addBuilding); $this-&gt;applyEvents($building); $checkInUser = Building\\Command\\CheckInUser::fromArray([ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username, ]); $building-&gt;checkInUser($checkInUser); $this-&gt;applyEvents($building); \/\/Test double check in $command = Building\\Command\\CheckInUser::fromArray([ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username, ]); $building-&gt;checkInUser($command); $events = $building-&gt;popRecordedEvents(); \/\/Another test helper to assert that list of recorded events contains given event $this-&gt;assertRecordedEvent(Event::DOUBLE_CHECK_IN_DETECTED, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username ], $events); \/\/And the other way round, list should not contain event with given name $this-&gt;assertNotRecordedEvent(Event::USER_CHECKED_IN, $events); } } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/tutorial\/bonusIV.html#2-12-13","title":"Wrap Up","content":"At this point the tutorial ends. Thank you for taking the tour through the world of CQRS and Event Sourcing with Event Machine. We started our tour with a rapid development approach. Event Machine really shines here. The skeleton application is preconfigured including some best practices like splitting Event Machine Descriptions by functionality. We learned how to react on domain events and how to project them into a read model, that we can access using queries and finders. All that with a minimum of boilerplate. Finally, Event Machine Flavours gave us a way to write more explicit code and harden the domain model. Every team can find its own style by mixing Flavours, conventions and serialization techniques.What's next?You can start to work on your own project. Event Machine docs cover advanced topics and a lot more details, but get some practice first and revisit them every now and then."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1","title":"Installation","content":"Event Machine is not a full stack framework. Instead you integrate it in any PHP framework that supports PHP Standards Recommendations."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-1","title":"Skeleton","content":"The easiest way to get started is by using the skeleton. It ships with a preconfigured Event Machine, a recommended project structure, ready-to-use docker containers and Zend Strategility to handle HTTP requests.The skeleton is not the only way to set up Event Machine. You can tweak set up as needed and integrate Event Machine with Symfony, Laravel or any other framework or middleware dispatcher."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-2","title":"Required Infrastructure","content":"Event Machine is based on PHP 7.1 or higher. Package dependencies are installed using composer."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-2-1","title":"Database","content":"Event Machine uses prooph\/event-store to store events recorded by the write model and a DocumentStore (see \"Document Store\" chapter) to store the read model.The skeleton uses prooph's Postgres event store and a Postgres Document Store implementation. This allows Event Machine to work with a single database, but that's not a requirement. You can mix and match as needed and also use a storage mechanism not implementing the document store interface by using custom projections (more on that in the \"projections\" chapter)."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-2-1-1","title":"Creating The Event Stream","content":"All events are stored in a single stream. You cannot change this strategy and prooph\/event-store has to be set up with the SingleStreamStrategy! The reason for this is that projections rely on a guaranteed order of events. A single stream is the only way to fulfill this requirement. When using a relational database as an event store a single table is also very efficient. A longer discussion about the topic can be found in the prooph\/pdo-event-store repo.An easy way to create the needed stream is to use the event store API directly.&lt;?php declare(strict_types=1); namespace Prooph\\EventMachine; use ArrayIterator; use Prooph\\EventStore\\EventStore; use Prooph\\EventStore\\Stream; use Prooph\\EventStore\\StreamName; require_once 'vendor\/autoload.php'; $container = require 'config\/container.php'; \/** @var EventStore $eventStore *\/ $eventStore = $container-&gt;get('EventMachine.EventStore'); $eventStore-&gt;create(new Stream(new StreamName('event_stream'), new ArrayIterator())); echo \"done.\\n\"; Such a script is used in the skeleton. As you can see we request the event store from a container that we get from a config file. The skeleton uses Zend Strategility and this is a common approach in Strategility (and Zend Expressive) based applications. If you want to use another framework, adopt the script accordingly. The only thing that really matters is that you get a configured prooph\/event-store from the PSR-11 container used by Event Machine."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-2-1-2","title":"Read Model Storage","content":"Read Model storage is set up on the fly. You don't need to prepare it upfront, but you can if you prefer to work with a database migration tool. It is up to you. Learn more about read model storage set up in the projections chapter."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-3","title":"Event Machine Descriptions","content":"Event Machine uses a \"zero configuration\" approach. While you have to configure integrated packages like prooph\/event-store, Event Machine itself does not require centralized configuration. Instead it loads so called Event Machine Descriptions:&lt;?php declare(strict_types=1); namespace Prooph\\EventMachine; interface EventMachineDescription { public static function describe(EventMachine $eventMachine): void; } Any class implementing the interface can be loaded by Event Machine. The task of a Description is to tell Event Machine how the application is structured. This is done in a programmatic way using Event Machine's registration API which we will cover in the next chapter. Here is a simple example of a Description that registers a command in Event Machine.&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; class Command implements EventMachineDescription { const COMMAND_CONTEXT = 'MyContext.'; const REGISTER_USER = self::COMMAND_CONTEXT . 'RegisterUser'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerCommand( self::REGISTER_USER, \/\/&lt;-- Name of the command defined as constant above JsonSchema::object([ Payload::USER_ID =&gt; Schema::userId(), Payload::USERNAME =&gt; Schema::username(), Payload::EMAIL =&gt; Schema::email(), ]) ); } } Now we only need to tell Event Machine that it should load the Description:declare(strict_types=1); require_once 'vendor\/autoload.php'; $eventMachine = new EventMachine(); $eventMachine-&gt;load(App\\Api\\Command::class); "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-4","title":"Initialize &amp; Bootstrap","content":"Event Machine is bootstrapped in three phases. Descriptions are loaded first, followed by a $eventMachine-&gt;initialize($container, $appVersion) call. Finally, $eventMachine-&gt;bootstrap($environment, $debugMode) prepares the system so that it can handle incoming messages.Bootstrapping is split because the description and initialization phases can be skipped in production. Read more about this in \"Optimize for production\" chapter."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-4-1","title":"Initialize","content":"Before caching of the configuration is possible Event Machine needs to aggregate information from all Descriptions. This is done in the Initialize phase. The phase also requires a PSR-11 container that can be used by Event Machine to get third-party services. See section about dependency injection for details.The second argument of the initialize method is a string representing the application version. It defaults to 0.1.0. The application version comes into play when organizing projections. More details can be found in the projections chapter."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/installation.html#3-1-1-4-2","title":"Bootstrap","content":"Last, but not least $eventMachine-&gt;bootstrap($environment, $debugMode) starts the engine and we're ready to take off. Event Machine supports 3 different environments: dev, prod and test. The environment is mainly used to set up third-party components like a logger.Same is true for the debug mode. It can be used to enable verbose logging or displaying of exceptions even if Event Machine runs in prod environment. You have to take care of this when setting up services. Event Machine just provides the information:Environment: $eventMachine-&gt;env(); \/\/ prod | dev | test Debug Mode: $eventMachine-&gt;debugMode(); \/\/ bool App Version: $eventMachine-&gt;appVersion(): \/\/ string -&gt; default: 0.1.0 "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2","title":"Dependency Injection","content":"As stated in the Initialize &amp; Bootstrap section, Event Machine pulls third-party dependencies from a PSR-11 container. It ships with its own 100 LoC container with the code name Disco Light (real class name is ReflectionBasedContainer). The implementation of Disco Light is inspired by the design of bitexpert\/disco but functionality is reduced to a bare minimum needed in a PHP 7.1+ environment. Hence, the code name ;)"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-1","title":"Required Services","content":"The container needs to provide a list of services required by Event Machine. For each of them a constant is defined. See the table below: Constant Value Service Description Mandatory EventMachine::SERVICE_ID_EVENT_STORE EventMachine.EventStore prooph\/event-store v7 event store Yes EventMachine::SERVICE_ID_SNAPSHOT_STORE EventMachine.SnapshotStore prooph\/event-store v7 snapshot store No EventMachine::SERVICE_ID_COMMAND_BUS EventMachine.CommandBus prooph\/service-bus v6 command bus Yes EventMachine::SERVICE_ID_EVENT_BUS EventMachine.EventBus prooph\/service-bus v6 event bus Yes EventMachine::SERVICE_ID_QUERY_BUS EventMachine.QueryBus prooph\/service-bus v6 query bus Yes EventMachine::SERVICE_ID_PROJECTION_MANAGER EventMachine.ProjectionManager prooph\/event-store v7 projection manager Yes EventMachine::SERVICE_ID_DOCUMENT_STORE EventMachine.DocumentStore Store implementing DocumentStore interface No EventMachine::SERVICE_ID_ASYNC_EVENT_PRODUCER EventMachine.AsyncEventProducer prooph\/service-bus v6 message producer No EventMachine::SERVICE_ID_MESSAGE_FACTORY EventMachine.MessageFactory prooph\/common v4 message factory (default provided) No EventMachine::SERVICE_ID_JSON_SCHEMA_ASSERTION EventMachine.JsonSchemaAssertion Class implementing JsonSchemaAssertion interface (default provided) No "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-2","title":"Default Services","content":"Event Machine ships with a default implementation for the last two services, a dedicated EventMachineContainer that provides the services and a ContainerChain to merge your container with the defaults:$myCustomContainer = include 'config\/container.php'; $defaultsContainer = new \\Prooph\\EventMachine\\Container\\EventMachineContainer($eventMachine); $psr11ContainerChain = new \\Prooph\\EventMachine\\Container\\ContainerChain($myCustomContainer, $defaultsContainer); $eventMachine-&gt;initalize($psr11ContainerChain); "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-3","title":"Working With Disco Light","content":"Remember the origin of Event Machine. It was designed as a workshop framework first. So one of the nice things about Disco Light is that dependencies are not wired together by a magical component but instead by the developer. This way they can learn the different parts of the system and what configuration is needed to get everything to work together. In the Event Machine Skeleton we've done that for you. A single class called the ServiceFactory is responsible for providing all services.You can find the ServiceFactory of the skeleton here"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-3-1","title":"Service Ids","content":"Let's look at the method which provides the service EventMachine.EventStore:public function eventStore(): EventStore { return $this-&gt;makeSingleton(EventStore::class, function () { $eventStore = new PostgresEventStore( $this-&gt;eventMachine()-&gt;messageFactory(), $this-&gt;pdoConnection(), $this-&gt;eventStorePersistenceStrategy() ); return new TransactionalActionEventEmitterEventStore( $eventStore, new ProophActionEventEmitter(TransactionalActionEventEmitterEventStore::ALL_EVENTS) ); }); } A lot of stuff going on here, so we'll look at it step by step.public function eventStore(): EventStore All public methods of the ServiceFactory are scanned by Disco Light (\\Prooph\\EventMachine\\Container\\ReflectionBasedContainer). The return type of the method is used as as service id. This means that you can do the following to get the event store from the container:$eventStore = $container-&gt;get(EventStore::class); "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-3-2","title":"Singleton Service","content":"In most cases we want to get the same instance of a service from the container no matter how often we request it. This is called a Singleton. Disco Light is dead simple. It does not know anything about singletons. Instead we use a pattern called memoization to cache the instance of a service in memory and return it from cache on subsequent calls.The ServiceFactory is a complete userland implementation. No interface needs to be implemented. To add memoization to your service factory you can use the provided trait \\Prooph\\EventMachine\\Container\\ServiceRegistry like it is done in the skeleton service factory.final class ServiceFactory { use ServiceRegistry; Now you can store service instances in memory:public function eventStore(): EventStore { return $this-&gt;makeSingleton(EventStore::class, function () { \/\/... }); } You might recognize that we use EventStore::class again as service id for the registry. The second argument of makeSingleton is a closure which acts as a factory function for the service. When EventStore::class is not in the cache, the factory function is called otherwise the service is returned from the registry."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-3-3","title":"Injecting Dependencies in a Service","content":"Often one service depends on other services. The Postgres event store used in the skeleton for example requires a MessageFactory a \\PDO connection and a PersistenceStrategy and because all services are provided by the same ServiceFactory we can simply get those services by calling the appropriate methods.By default a closure is bound to its parent scope (the service factory instance in this case). Hence, insight the closure we have access to all methods of the service factory no matter if they are declared public, protected or private.public function eventStore(): EventStore { return $this-&gt;makeSingleton(EventStore::class, function () { $eventStore = new PostgresEventStore( $this-&gt;eventMachine()-&gt;messageFactory(), $this-&gt;pdoConnection(), $this-&gt;eventStorePersistenceStrategy() ); return new TransactionalActionEventEmitterEventStore( $eventStore, new ProophActionEventEmitter(TransactionalActionEventEmitterEventStore::ALL_EVENTS) ); }); } The event store interface is service id and return type at the same time. Therefor, PHP's type system ensures at runtime that a valid event store is returned. Internally, we built a Postgres event store and add prooph's plugin system (the TransactionalActionEventEmitterEventStore). If we want to switch the event store we can return another implementation."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-3-4","title":"Configuration","content":"Another thing that is out of scope for Disco Light is application configuration. Remember, providing a working ServiceFactory is your task and if services need configuration then pass it to the class. In the skeleton environmental variables are mapped to config params in config\/autoload\/global.php.The configuration array is then passed to the ServiceFactory in the constructor and wrapped with an ArrayReader:final class ServiceFactory { use ServiceRegistry; \/\/... public function __construct(array $appConfig) { $this-&gt;config = new ArrayReader($appConfig); } This way we have access to the configuration when building our services. We can see this in action in the factory method of the \\PDO connection:public function pdoConnection(): \\PDO { return $this-&gt;makeSingleton(\\PDO::class, function () { $this-&gt;assertMandatoryConfigExists('pdo.dsn'); $this-&gt;assertMandatoryConfigExists('pdo.user'); $this-&gt;assertMandatoryConfigExists('pdo.pwd'); return new \\PDO( $this-&gt;config-&gt;stringValue('pdo.dsn'), $this-&gt;config-&gt;stringValue('pdo.user'), $this-&gt;config-&gt;stringValue('pdo.pwd') ); }); } $this-&gt;assertMandatoryConfigExists(\/*...*\/) is a helper function of the ServiceFactory marked as private. It is ignored by Disco Light but we can use it within factory functions.private function assertMandatoryConfigExists(string $path): void { if(null === $this-&gt;config-&gt;mixedValue($path)) { throw new \\RuntimeException(\"Missing application config for $path\"); } } Again, this is all userland implementation. Disco Light does not care about it. If you don't like it to put all services in a single class then use traits and only merge them in the ServiceFactory. And if you don't like the approach at all, use another PSR-11 container! In any case you can learn from the skeleton service factory how the mandatory services need to be wired together. Porting this knowledge to a container of your choice shouldn't be a problem."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-3-5","title":"Service Alias","content":"If you've read the explanations above carefully, you might have noticed a mismatch between the service id required by Event Machine and the service id used in Disco Light. Event Machine requires the service id EventMachine.EventStore. But we've learned that we get the event store by using the interface or class name as service id $eventStore = $container-&gt;get(EventStore::class);.To solve the conflict we need a service alias. That said, the same service needs to be available in the container with two different ids. We can do this by passing a service alias map to Disco Light aka ReflectionBasedContainer:$container = new \\Prooph\\EventMachine\\Container\\ReflectionBasedContainer( $serviceFactory, [ \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_EVENT_STORE =&gt; \\Prooph\\EventStore\\EventStore::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_PROJECTION_MANAGER =&gt; \\Prooph\\EventStore\\Projection\\ProjectionManager::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_COMMAND_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\CommandBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_EVENT_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\EventBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_QUERY_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\QueryBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_DOCUMENT_STORE =&gt; \\Prooph\\EventMachine\\Persistence\\DocumentStore::class, ] ); "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/di.html#3-1-2-4","title":"Put it all together","content":"Again, we can look at the skeleton for a working example. [config\/container.php]: includes the application config passes it to a new instance of the ServiceFactory passes the ServiceFactory and service alias map to a new ReflectionBasedContainer hands over the container to the ServiceFactory (setter injection due to circular dependency) and finally returns the container &lt;?php declare(strict_types = 1); $config = include 'config.php'; $serviceFactory = new \\App\\Service\\ServiceFactory($config); $container = new \\Prooph\\EventMachine\\Container\\ReflectionBasedContainer( $serviceFactory, [ \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_EVENT_STORE =&gt; \\Prooph\\EventStore\\EventStore::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_PROJECTION_MANAGER =&gt; \\Prooph\\EventStore\\Projection\\ProjectionManager::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_COMMAND_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\CommandBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_EVENT_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\EventBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_QUERY_BUS =&gt; \\App\\Infrastructure\\ServiceBus\\QueryBus::class, \\Prooph\\EventMachine\\EventMachine::SERVICE_ID_DOCUMENT_STORE =&gt; \\Prooph\\EventMachine\\Persistence\\DocumentStore::class, ] ); $serviceFactory-&gt;setContainer($container); return $container; Note: The container is passed to the service factory because the factory needs to pass it to Event Machine as soon as Event Machine is requested for the first time."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/set_up\/production_optimization.html#3-1-3","title":"Optimize For Production","content":"Work in ProgressThe Description phase configures Event Machine. Depending on the size of the application this can result in many method calls which are known to be slow. During development that's not a problem but in production you don't want to do that on every request. Between two deployments code does not change and therefor the configuration does not change. We can safely cache it and respond faster to requests."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/descriptions.html#3-2","title":"Event Machine Descriptions","content":"In the previous chapter \"Set Up\" we already learned that Event Machine loads EventMachineDescriptions and passes itself as the only argument to a static describe method.&lt;?php declare(strict_types=1); namespace Prooph\\EventMachine; interface EventMachineDescription { public static function describe(EventMachine $eventMachine): void; } Descriptions need to be loaded before EventMachine::initialize() is called.In the skeleton descriptions are listed in config\/autoload\/global.php and this list is read by the event machine factory method of the ServiceFactory:public function eventMachine(): EventMachine { $this-&gt;assertContainerIsset(); return $this-&gt;makeSingleton(EventMachine::class, function () { $eventMachine = new EventMachine(); \/\/Load descriptions here or add them to config\/autoload\/global.php foreach ($this-&gt;config-&gt;arrayValue('event_machine.descriptions') as $desc) { $eventMachine-&gt;load($desc); } $containerChain = new ContainerChain( $this-&gt;container, new EventMachineContainer($eventMachine) ); $eventMachine-&gt;initialize($containerChain); return $eventMachine; }); } Organising Descriptions: If you followed the tutorial, you already know that you can avoid code duplication and typing errors with a few simple tricks. Clever combinations of class and constant names can provide readable code without much effort. The skeleton ships with default Event Machine Descriptions to support you with that idea. You can find them in src\/Api"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/descriptions.html#3-2-1","title":"Registration API","content":"Event Machine provides various registration methods. Those methods can only be called during description phase (see \"Set Up\" chapter for details about bootstrap phases). Here is an overview of available methods:&lt;?php declare(strict_types=1); namespace Prooph\\EventMachine; \/\/... final class EventMachine implements MessageDispatcher, AggregateStateStore { \/\/... \/** * Add a command message to the system along with its payload schema *\/ public function registerCommand(string $commandName, ObjectType $schema): self { \/\/... } \/** * Add an event message to the system along with its payload schema *\/ public function registerEvent(string $eventName, ObjectType $schema): self { \/\/... } \/** * Add a query message to the system along with its payload schema *\/ public function registerQuery(string $queryName, ObjectType $payloadSchema = null): QueryDescription { \/\/... } \/** * Add a data type to the system along with its json schema *\/ public function registerType(string $nameOrImmutableRecordClass, ObjectType $schema = null): void { \/\/... } \/** * Add an enum type to the system along with its json schema *\/ public function registerEnumType(string $typeName, EnumType $schema): void { \/\/... } \/** * Service id or instance of a CommandPreProcessor invoked before command is dispatched * * @param string $commandName * @param string | CommandPreProcessor $preProcessor *\/ public function preProcess(string $commandName, $preProcessor): self { \/\/... } \/** * Describe handling of a command using returned CommandProcessorDescription *\/ public function process(string $commandName): CommandProcessorDescription { \/\/... } \/** * Service id or callable event listener invoked after event is written to event stream * * @param string $eventName * @param string | callable $listener *\/ public function on(string $eventName, $listener): self { \/\/... } \/** * Describe a projection by using returned ProjectionDescription *\/ public function watch(Stream $stream): ProjectionDescription { \/\/... } \/\/... } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/descriptions.html#3-2-2","title":"Message Payload Schema","content":"Messages are like HTTP requests, but they are protocol agnostic. For HTTP requests\/responses PHP-FIG has defined a standard known as PSR-7. Event Machine messages on the other hand are prooph\/common messages.Like HTTP requests messages should be validated before doing anything with them. It can become a time consuming task to write validation logic for each message by hand. Hence, Event Machine has a built-in way to validate messages using Json Schema Draft 6. You do this using JsonSchema wrapper objects provided by Event Machine. Those objects are simple to use and drastically improve readability of the code.Again the command registration example from the previous chapter:$eventMachine-&gt;registerCommand( self::REGISTER_USER, JsonSchema::object([ Payload::USER_ID =&gt; Schema::userId(), Payload::USERNAME =&gt; Schema::username(), Payload::EMAIL =&gt; Schema::email(), ]) ); This code speaks for itself, doesn't it? It is beautiful and clean (IMHO) and once you're used to it you can add new messages to the system in less than 30 seconds. The chapter about \"Json Schema\" covers all the details. Make sure to check it out.A nice side effect of this approach is out-of-the-box Swagger UI support. Learn more about it in the \"Swagger UI\" chapter."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/descriptions.html#3-2-3","title":"Command Registration","content":"Event Machine needs to know which commands can be processed by the system. Therefor, you have to register them before defining processing logic.Software developed with Event Machine follows a Command-Query-Responsibility-Segregation (short CQRS) approach. Commands are used to trigger state changes without returning modified state and queries are used to request current state without modifying it.You're ask to tell Event Machine a few details about available commands. Each command should have a unique name and a payload schema. It is recommended to add a context as prefix in front of each command name. Let's take an example from the tutorial but add a context to the command name:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use Prooph\\EventMachine\\JsonSchema\\JsonSchema; class Command implements EventMachineDescription { const CMD_CXT = 'BuildingMgmt.'; const ADD_BUILDING = self::CMD_CXT.'AddBuilding'; \/** * @param EventMachine $eventMachine *\/ public static function describe(EventMachine $eventMachine): void { $eventMachine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ 'buildingId' =&gt; JsonSchema::uuid(), 'name' =&gt; JsonSchema::string()-&gt;withMinLength(2) ] ) ); } } Event Machine makes no assumptions about the format of the name. A common approach is to use a dot notation to separate context from message name e.g. BuildingMgmt.AddBuilding. Using dot notation has the advantage that message broker like RabbitMQ can use it for routing."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/descriptions.html#3-2-4","title":"Command Processing","content":"Once Event Machine knows about a command you can register processing logic for it. Commands are processed by aggregate functions. Think of an aggregate as a process with multiple steps. Each step is triggered by a command and there is only one active step for a specific process aka. aggregate at the same time.In Event Machine aggregate functions are stateless. You can use plain PHP functions or classes with static public methods.Before we dive deeper into aggregate functions, let's have a look at how commands are processed. The following gif shows the power of Event Machine Descriptions especially CommandProcessingDescription. A fluent interface mixed with clever class and constant naming + modern IDE support (PHPStorm in this case) can assist you while putting together the pieces. You need to remember less which frees your mind to reason more about the logic you're developing. This results in a higher quality business logic, written in a shorter time. Try it yourself. It's actually a lot of fun to work with Event Machine.Keep an eye on the array callable syntax: [ShoppingCart::class, 'addItem']. PHPStorm provides code completion for it and respects it while renaming methods and classes. That's an awesome feature and makes the syntax save to use.Event Machine Descriptions keep glue code outside of the core business logic. This reduces \"noise\" in the core and creates a central overview for navigation through the code.Details about the various Description types can be found in their respective chapters like \"aggregates\", \"event listeners\" and \"projections\"."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3","title":"Functional Flavour","content":" Event Sourced Aggregates are Domain-Driven Aggregates, representing a unit of consistency. They protect invariants. This basically means that an aggregate makes sure that it can transition to a new state. Different business rules can permit or prevent state transitions, and the aggregate has to enforce these business rules. Source: http:\/\/docs.getprooph.org\/tutorial\/event_sourcing_basics.html#1-3-3"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3-1","title":"Functions vs. Objects","content":"Event Machine supports three programming styles out-of-the-box: OopFlavour, PrototypingFlavour and FunctionalFlavour.On this page we focus on the Prototyping and Functional Flavour. Both follow the same idea of a functional core. vent Sourcing is heavily based on functional patterns: immutable events, append-only streams, left fold of past events to calculate current state, ...The difference between Prototyping and Functional is that the PrototypingFlavour uses generic Event Machine messages while the FunctionalFlavour is 100% decoupled from Event Machine. Code examples shown here are based on the PrototypingFlavour. If you're curious how you can switch to another Flavour, then check out the Event Machine tutorial. It covers all three Flavours in detail.Event Machine grows with your application from prototype to MVP up to a rock solid production system. And it is able to reduce boilerplate code to a bare minimum because of a few \"simple\" rules:"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3-2","title":"1. Pure Functions","content":"Given the same input a pure function will always produce the same result.Here is the simplest form of a pure aggregate function in Event Machine:"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3-2-1","title":"prooph\/micro style","content":"\/\/some_business_process.php declare(strict_types=1); Namespace Acme\\Model\\SomeBusinessProcess; use Prooph\\EventMachine\\Messaging\\Message; use Acme\\Api\\Event; const startProcess = '\\Acme\\SomeBusinessProcess\\startProcess'; function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } \/\/More functions .... "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3-2-2","title":"Static method style","content":"\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use Prooph\\EventMachine\\Messaging\\Message; use Acme\\Api\\Event; final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } \/\/more methods .... } As you can see both approaches are very similar. The prooph\/micro style looks more functional and underlines the intention of the code whereby the static method approach plays nice together with a modern IDE and PHP's autoloader. We'll stick to the static method approach in the examples because this is the recommended style when working with Event Machine. But prooph\/micro style can be used, too!Back to the pure nature of both approaches. No matter how often you call the function as long as the input message payload does not change, the yielded event won't change, too.This property makes testing the function a breeze. You don't need mocks. You don't need heavy fixture setup. Just create the appropriate message, call the function and test against an expected event."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3-3","title":"2. Stateless Functions","content":"No object, no internal state and therefor a much simpler business logic implementation, which is easy to test, refactor and maintain!But even if we use functions, we have to be careful to not fall into the trap of modifying state:"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3-3-1","title":"Evil Global Variable","content":"One way to break the rule with a function is by modifying global state.\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use Prooph\\EventMachine\\Messaging\\Message; use Acme\\Api\\Event; $evilState = new EvilState(); final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { global $evilState; $evilState-&gt;burnStatelessApproach(); yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } \/\/more methods .... } Never ever do this! Don't even think about it!"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3-3-2","title":"Evil Static Property","content":"Another way to break our stateless function:\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use Prooph\\EventMachine\\Messaging\\Message; use Acme\\Api\\Event; final class SomeBusinessProcess { private static $evilState; public static function startProcess(Message $startProcess): \\Generator { self::$evilState = new EvilState(); yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } public static funcion continueProcess(Message $continue): \\Generator { yield [Event::SOME_PROCESS_CONTINUED, self::$evilState-&gt;toArray()]; } \/\/more methods .... } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3-3-3","title":"Evil Static Local Variable","content":"That's also a very bad idea:\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use Prooph\\EventMachine\\Messaging\\Message; use Acme\\Api\\Event; final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } public static funcion continueProcess(Message $continue): \\Generator { static $evilCounter; if($evilCounter === null) { $evilCounter = 0; } yield [Event::SOME_PROCESS_CONTINUED, ['counter' =&gt; ++$evilCounter]]; } \/\/more methods .... } "},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3-3-4","title":"Evil Mutable State Passed As Argument","content":"Mutable state passed as an argument is probably the easiest way to break the stateless rule. Let's look at an evil example first and then we'll see how we can do better.\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use Prooph\\EventMachine\\Messaging\\Message; use Acme\\Api\\Event; final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } public static funcion continueProcess(EvilMutableState $evilState, Message $continue): \\Generator { $evilState-&gt;burnStatelessApproach(); yield [Event::SOME_PROCESS_CONTINUED, ['state' =&gt; $evilState-&gt;toArray()]]; } \/\/more methods .... } Let's fight the evil!\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use Prooph\\EventMachine\\Messaging\\Message; use Acme\\Api\\Event; use Acme\\Api\\Payload; final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } public static function whenProcessStarted(Message $processStarted): ImmutableState { return new ImmutableState(); } public static funcion continueProcess(ImmutableState $state, Message $continue): \\Generator { if($state-&gt;wantsToBurnStatelessApproach()) { yield [Event::STATE_MUTATION_BLOCKED, [Payload::ALTERNATIVE =&gt; $continue-&gt;get(Payload::ALTERNATIVE)]]; } } public static function whenStateMutationBlocked(ImmutableState $currentState, Message $stateMutationBlocked): ImmutableState { return $currentState-&gt;withAlternativeMutation($stateMutationBlocked-&gt;get(Payload::ALTERNATIVE)); } } Ok, we see two new functions here. Both start with when followed by an event name.Note: The naming is only a recommendation.Those when functions do not take commands as input and do not yield events, but instead take yielded events as input and return (note the difference to yield) ImmutableState. The second when function even takes ImmutableState as an argument and returns it.To be able to understand the alternative to mutable state we have to jump into the method withAlternativeMutation:declare(strict_types=1); Namespace Acme\\Model; final class ImmutableState { private $alternative; public function alternative(): ?string { return $this-&gt;alternative; } public function withAlternativeMutation(string $alternative): self { $copy = clone $this; $copy-&gt;alternative = $alternative; return $copy; } } This is how state of an immutable value object is changed. Instead of modifying internal state directly, the value object copies itself and modfies the copy instead.It works because visibility of properties and methods is defined on class level and not on instance level.Let's look at the effect with a unit test:declare(strict_types=1); Namespace AcmeTest\\Model; use Acme\\Api\\Event; use Acme\\Api\\Payload; use Acme\\Model\\SomeBusinessProcess; use Acme\\Model\\ImmutableState; use AcmeTest\\BaseTestCase; \/\/&lt;-- extends PHPUnit\\Framework\\TestCase + provides message factory use Prooph\\EventMachine\\Messaging\\Message; final class SomeBusinessProcessTest extends BaseTestCase { \/** * @test *\/ public function it_does_not_change_input_state() { $inputState = new ImmutableState(); $this-&gt;assertNull($inputState-&gt;alternative()); $event = $this-&gt;messageFactory()-&gt;createMessageFromArray( Event::STATE_MUTATION_BLOCKED, [ 'payload' =&gt; [ 'alternative' =&gt; 'modify and return copy' ] ] ); $outputState = SomeBusinessProcess::whenStateMutationBlocked( $inputState, $event ); $this-&gt;assertNull($inputState-&gt;alternative()); $this-&gt;assertSame( 'modify and return copy', $outputState-&gt;alternative() ); } } Working with immutable state avoids a whole bunch of silly and hidden errors. Function calls are predictable. You can harden the system With simple tests, pave the way for refactorings and keep velocity high. Event Machine also has an easy job. It does not need to care about state changes, because they are fully managed in userland code. This means, that you have full control. No object mapping layer required, no dirty state and no unit of work.The \"Immutable State\" chapter provides a lot of tips and tricks to rapidly create and work with immutable value objects."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3-4","title":"3. Side-Effect Free Functions","content":"Modifying global state is one kind of side-effect, I\/O is another. I\/O is the short term for Input\/Output and includes things like reading from or writing to a database, accessing the filesystem or calling a remote service. It describes any operation that might fail due to unavailability of the target system. If a function (or method) performs a database query but the database is down, the function will behave different than in normal cases. Hence, the result of the function call is not predictable.Side-Effects make testing harder. Performing I\/O usually requires mocking and you have to test against more scenarios. That's a bad situation specifically for business logic tests. When testing business logic you should focus on its behaviour and only on that! Mixing I\/O into the game makes it difficult.If we must not query a database or call a remote service in aggregate functions, where do we do it then? Well, outside of the functional core. The following diagram illustrates that idea.The diagram shows three layers. The outermost layer is where I\/O happens. Event Machine acts as a middleware between I\/O layer and the functional core."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3-5","title":"Read I\/O","content":"We can tell Event Machine to invoke a ContextProvider before invoking an aggregate function. That's the preferred way to perform read I\/O to query data needed by the aggregate.&lt;?php declare(strict_types=1); namespace Prooph\\EventMachine\\Aggregate; use Prooph\\EventMachine\\Messaging\\Message; interface ContextProvider { \/** * @param Message $command * @return mixed The context passed as last argument to aggregate functions *\/ public function provide(Message $command); } Let's say we have a shopping cart aggregate that processes AddItem commands. The command payload only contains the itemId but we also need the price of the item to enable free shipping if a certain order sum is reached.Context Provider: uses a price finder to get item price from a database and sets up a free shipping policy with 40,- \u00e2\u0082\u00ac (4000 Cent) as minimum order sum.&lt;?php declare(strict_types=1); namespace ProophExample\\ContextProvider; use Prooph\\EventMachine\\Aggregate\\ContextProvider; use Prooph\\EventMachine\\Messaging\\Message; use ProophExample\\ContextProvider\\Api\\Payload; use ProophExample\\ContextProvider\\Policy\\FreeShipping; use ProophExample\\ContextProvider\\ShoppingCart\\AddItemContext; final class AddItemContextProvider implements ContextProvider { \/** * @var PriceFinder *\/ private $priceFinder; \/** * @param Message $command * @return mixed The context passed as last argument to aggregate functions *\/ public function provide(Message $command) { $itemId = ItemId::fromString($command-&gt;get(Payload::ITEM_ID)); $itemPrice = $this-&gt;priceFinder-&gt;findItemPrice($itemId); $item = Item::withIdAndPrice($itemId, $itemPrice); $freeShipping = FreeShipping::fromInt(4000); return AddItemContext::fromRecordData(['item' =&gt; $item, 'freeShipping' =&gt; $freeShipping]); } } Command Processing Description: AddItemContextProvider service id (FQCN) is passed to provideContext.&lt;?php declare(strict_types=1); namespace ProophExample\\ContextProvider\\Api; use Prooph\\EventMachine\\EventMachine; use Prooph\\EventMachine\\EventMachineDescription; use ProophExample\\ContextProvider\\AddItemContextProvider; use ProophExample\\ContextProvider\\ShoppingCart; final class Aggregate implements EventMachineDescription { const SHOPPING_CART = 'ShoppingCart'; public static function describe(EventMachine $eventMachine): void { \/\/... $eventMachine-&gt;process(Command::ADD_ITEM) -&gt;withExisting(self::SHOPPING_CART) -&gt;provideContext(AddItemContextProvider::class) -&gt;handle([ShoppingCart::class, 'addItem']) -&gt;recordThat(Event::ITEM_ADDED) -&gt;apply([ShoppingCart::class, 'whenItemAdded']) -&gt;andRecordThat(Event::FREE_SHIPPING_ENABLED) -&gt;apply([ShoppingCart::class, 'whenFreeShippingEnabled']); } } Shopping Cart Aggregate: receives AddItemContext as third argument in the addItem function&lt;?php declare(strict_types=1); namespace ProophExample\\ContextProvider; use Prooph\\EventMachine\\Messaging\\Message; use ProophExample\\ContextProvider\\Api\\Event; use ProophExample\\ContextProvider\\Api\\Payload; use ProophExample\\ContextProvider\\ShoppingCart\\AddItemContext; use ProophExample\\ContextProvider\\ShoppingCart\\State; final class ShoppingCart { \/\/... public static function addItem(State $cart, Message $addItem, AddItemContext $context): \\Generator { yield [Event::ITEM_ADDED, [ Payload::SHOPPING_CART_ID =&gt; $addItem-&gt;get(Payload::SHOPPING_CART_ID), Payload::ITEM =&gt; $context-&gt;item()-&gt;toArray(), ]]; if(!$cart-&gt;freeShipping()) { \/\/Temporarily add item. We can safely do this, because $cart is immutable $cart = $cart-&gt;withAddedItem($context-&gt;item()); if($context-&gt;freeShipping()-&gt;isFree($cart-&gt;orderSum())) { yield [Event::FREE_SHIPPING_ENABLED, [ Payload::SHOPPING_CART_ID =&gt; $addItem-&gt;get(Payload::SHOPPING_CART_ID), ]]; } } } public static function whenItemAdded(State $cart, Message $itemAdded): State { return $cart-&gt;withAddedItem(Item::fromArray($itemAdded-&gt;get(Payload::ITEM))); } public static function whenFreeShippingEnabled(State $cart, Message $freeShippingEnabled): State { return $cart-&gt;withFreeShippingEnabled(); } } Full example code can be found in the \"examples\/ContextProvider\" dir of the event-machine-docs repository on Github."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3-6","title":"Write I\/O","content":"Event Machine appends all yielded events to the write model event stream. You don't need to care about that. Read model updates are performed by projections (see \"Projections\" chapter) and all other Write I\/O should happen in event listeners (see \"Event Listeners\" chapter).Aggregate functions should NEVER perform any write operation directly but only yield events to trigger Write I\/O in the outermost layer."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3-7","title":"Aggregate Lifecycle","content":"If an aggregate is composed of pure functions and those functions work with immutable state only, does the aggregate have a lifecycle?Yes! An aggregate has a lifecycle. It is just not implemented as an object that changes internal state over time. But an aggregate is still a domain concept - a business process. Each aggregate has a unique id and yielded events should contain that id (otherwise Event Machine throws an exception) so that the events can be added to the event stream of the aggregate. An event stream can be seen as a timeline. It tracks all important facts about the aggregate.But how can Event Machine always pass the current state of an aggregate to the next function?It seems like aggregate state is magically passed to aggregate functions. But the mechanism used by Event Machine is relatively simple. It is best explained with our shopping cart example again.$eventMachine-&gt;process(Command::START_SHOPPING_SESSION) -&gt;withNew(self::SHOPPING_CART) -&gt;identifiedBy(Payload::SHOPPING_CART_ID) Event Machine gets two important information here. The first one is that the lifecycle of our ShoppingCart aggregate begins with a StartShoppingSession command. And the second is that a ShoppingCart is identified by its ShoppingCartId. All commands addressing the shopping cart should contain the ShoppingCartId and all events yielded by the aggregate should contain the same id.$eventMachine-&gt;process(Command::START_SHOPPING_SESSION) -&gt;withNew(self::SHOPPING_CART) -&gt;identifiedBy(Payload::SHOPPING_CART_ID) -&gt;handle([ShoppingCart::class, 'startShoppingSession']) Given the information above, Event Machine knows that the aggregae function ShoppingCart::startShoppingSession() only takes a StartShoppingSession command as argument. Aggregate state doesn't exist at this time because it's the first command.&lt;?php \/\/... final class ShoppingCart { public static function startShoppingSession(Message $startShoppingSession): \\Generator { yield [Event::SHOPPING_SESSION_STARTED, [ Payload::SHOPPING_CART_ID =&gt; $startShoppingSession-&gt;get(Payload::SHOPPING_CART_ID), ]]; } \/\/... } Event Machine will append the yielded ShoppingSessionStarted event to its write model event stream. This event will mark the beginning of a new shopping cart lifecycle.Every yielded event should have a corresponding apply function. Event Machine takes care of that rule. It's the last part of every CommandProcessingDescription.$eventMachine-&gt;process(Command::START_SHOPPING_SESSION) -&gt;withNew(self::SHOPPING_CART) -&gt;identifiedBy(Payload::SHOPPING_CART_ID) -&gt;handle([ShoppingCart::class, 'startShoppingSession']) -&gt;recordThat(Event::SHOPPING_SESSION_STARTED) -&gt;apply([ShoppingCart::class, 'whenShoppingSessionStarted']); A recordThat call should always be followed by an apply call. Obvousely, it's a mapping so that Event Machine knows which apply function to use. And because the entire description is bound to the command being processed, Event Machine knows again that ShoppingCart::whenShoppingSessionStarted is the first apply function and therefor does not take aggregate state as an argument. But the apply function should return the first immutable state derived from the first event.&lt;?php \/\/... final class ShoppingCart { \/\/... public static function whenShoppingSessionStarted(Message $shoppingSessionStarted): State { return State::newSession(ShoppingCartId::fromString( $shoppingSessionStarted-&gt;get(Payload::SHOPPING_CART_ID) )); } } All subsequent aggregate functions (command handling and event applying functions) receive the current aggregate state as the first argument.The following diagram illustrates how Event Machine calculates current state with the help of the apply functions."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/functional_flavour.html#3-3-8","title":"RecordThat","content":"The CommandProcessingDescription defines two aliases for recordThat: andRecordThat and orRecordThat. You can use them when an aggregate function yields multiple events (andRecordThat) or different events depending on conditions (orRecordThat).Event Machine doesn't really care about which variant you use, but if an aggregate function yields an unknown event (no recordThat-&gt;apply pair defined) Event Machine will throw an exception.$eventMachine-&gt;process(Command::ADD_ITEM) -&gt;withExisting(self::SHOPPING_CART) -&gt;provideContext(AddItemContextProvider::class) -&gt;handle([ShoppingCart::class, 'addItem']) -&gt;recordThat(Event::ITEM_ADDED) -&gt;apply([ShoppingCart::class, 'whenItemAdded']) -&gt;andRecordThat(Event::FREE_SHIPPING_ENABLED) -&gt;apply([ShoppingCart::class, 'whenFreeShippingEnabled']); It's not required that all events are yielded each time. The main thing is that Event Machine knows about them all. In some situations an aggregate function does not want to yield any new event. In such a case you can yield null and return from the function.&lt;?php \/\/... final class ShoppingCart { \/\/... public static function removeItem(State $cart, Message $removeItem): \\Generator { $item = Item::fromArray($removeItem-&gt;get(Payload::ITEM)); if(!$cart-&gt;hasItem($item)) { yield null; return; } yield [Event::ITEM_REMOVED, $removeItem-&gt;payload()]; } } Wrap UP: Aggregates in Event Machine are composed of pure functions and immutable state (when using Prototyping or Functional Flavour). Command Processing Descriptions tell Event Machine how the pieces fit together. This reduces boilerpate code and we can focus on the domain and avoid silly bugs that interrupt our model exploration.In the next chapter you'll learn how immutable value objects can be generated quickly."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/immutable_state.html#3-4","title":"Immutable State","content":"Work in Progress"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/document_store\/set_up.html#3-5-1","title":"Document Store","content":"Work in Progress"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/api\/projections\/set_up.html#3-6-1","title":"Custom Projections","content":"Work in Progress"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1","title":"Future of Event Machine","content":"Written by Alexander Miertsch (@codeliner) - CEO prooph software GmbH - prooph core team - 2018-09-08You may have read the official announcement by Sascha (@prolic) about the future of prooph components. Together with Sascha we decided to stop working on prooph\/common, prooph\/event-sourcing, prooph\/service-bus and all related packages like the various message queue adapters.Event Machine makes use of the packages so one may ask if Event Machine is effected by this announcement as well? The short answer is:Yes it is effected but we continue to work on Event Machine.If you want to know the reasoning behind these decisions and what we plan to do (prooph software GmbH team), this post provides you with answers."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-1","title":"Dropping Event Sourcing","content":"I'd like to go into details about the prooph components decision first. I think it is important to understand the reasoning and it will give you a better idea of what you can expect from Event Machine in the future.As the author of the very first prooph components back in 2014 I'm involved in core development since the first commit. prooph\/common and prooph\/event-sourcing always had the problem that one needs to extend message classes and aggregate roots from prooph. You can use custom messages and aggregate root implementations but this is not an easy task within the current design of the components. It's a big issue because prooph never wanted to be a framework. Independent components have a very high priority for the core team. Prooph is meant to be used in enterprise applications which should not be coupled to a framework.With a completely new event store implementation in the pipeline we revisited the problem. And because more teams use prooph in production, we receive requests from the community to provide better ways for custom messages as well as project specific needs for message serialization and such things.Now we could try to support all those concerns by adding more and more possibilities to tweak prooph, but this has a high price: complexity Even with the current design of prooph components one has a hard time to get started. A reason why Event Machine exists. If we would add more configuration options and whatnot, it would get worse.Back in the days, I started working on prooph because CQRS and Event Sourcing is a fascinating approach and can inspire you to solve problems in a completely different way. It needs some time and practice to get it right. Hence, battle-tested open source components might help developers to learn it without making the same mistakes. This still holds true, but can be limited to a proper event store implementation (including at-least-once message delivery for projections). We believe that a good event sourcing tutorial together with blueprints for event sourced aggregates and their repositories and a rock-solid prooph\/event-store available as open source is the better approach for the prooph community. New developers get a recipe to get started and can rely on a high quality event store implementation. If the provided event sourcing blueprint doesn't fit a use case it can easily be adopted because the team owns the event sourcing code as well as the repository implementation that talks to prooph\/event-store."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-2","title":"Dropping Service Bus","content":"Dropping development of prooph\/service-bus has other reasons. The component is designed to run in a modular application - think of ZF2 MVC or Symfony bundles. Since 2014 things have changed. The Zend Framework team promotes usage of zend expressive. Symfony made it easier to develop bundle-less applications. That said, nowadays both major frameworks advocate smaller application size with less layers and less complexity.Prooph components do the same with prooph\/micro, which doesn't use prooph\/service-bus. A software service bus introduces an additional layer. This is especially useful in a modularized monolithic application. If you don't use modules, you don't need a software bus or at least nothing with the complexity of prooph\/service-bus. For our daily work we no longer need prooph\/service-bus and that's true for Sascha (he is not working for prooph software), too.Hence, we decided together that if one needs a software message bus they have a lot of similar choices today. We don't need to spend our time on maintaining yet another solution.If I could buy time with money, I'd do it and all prooph components would have a \"buy me a minute\" donation button. But you cannot buy time (yet?), therefor we need to be very careful with it. Working on open source is a great experience especially within the prooph community. On the other hand it reduces available time a lot and always competes with family and friends time as well as payed work. Many big open source projects are baked by companies with even bigger budgets, but that's a different league. The prooph community is awesome. Join the improoph chat and you'll know what I mean. But we don't have core developers who get payed to maintain prooph. It's more or less all based on community work.Not enough time, new software architecture approaches and the availability of other software message bus solutions are the reasons for dropping prooph\/service-bus support. It's still a great package, so this decision is not an easy one."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-3","title":"Components vs Event Machine","content":"Now let's look at Event Machine. prooph\/event-sourcing and prooph\/service-bus are both used under the hood. The good news is, that you don't interact with them directly so we can easily replace the packages. But what about the reasons? Don't they apply for Event Machine as well?I'm going to answer for each:"},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-3-1","title":"Framework Dependency","content":"Event Machine is a rapid application development framework. You either use it as-is or don't use it at all. That's a big difference compared to prooph components and also the reason why Event Machine is not part of the prooph components family but only maintained by the prooph software team (different vendor, different copyright). My company is interested in future development because we need it for our daily work.Event Machine is a great way to explore the world of CQRS and Event Sourcing without learning all theory upfront and spending days on putting all the pieces together. It is also a great way to develop prototypes and smaller applications. If you practice Domain-Driven Design, you probably know the difference between core domain and supporting domain. You should also know that it is not a good idea to solve all software problems with high quality implementations but rather focus on the core domain and design the rest of the system in a way that it works and is maintainable without too much effort. Event Machine is best used in supporting domains. It can be used for prototypes of core domains but only if you design the core domain in a way that you can easily delete and replace parts of it.Having said this, Event Machine doesn't have the same problem like prooph\/event-sourcing. A service developed with Event Machine is coupled by design. You need to be aware of the coupling and decide upfront (or after prototype phase) if that is ok for the service or not."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-3-2","title":"Modules","content":"It is not recommended to develop a monolith with Event Machine. The concept works really nice within clear service boundaries. Therefor, Event Machine doesn't need a complex message bus. prooph\/service-bus was integrated because early versions of Event Machine were used as a workshop framework - a prooph components glue layer. Replacing the service-bus package with a simple message dispatcher implementation isn't problematic."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-3-3","title":"Available Time","content":"As I already said, we need Event Machine for our daily work so prooph software GmbH is interested in ongoing development. This is also true for the new prooph\/event-store implementation which will become the heart of Event Machine 2.0."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-3-4","title":"Competing Solutions","content":"I'm not aware of any PHP open source library\/framework that provides similar mechanisms like Event Machine does. prooph\/micro is based on the same idea of functional event sourced domain behaviour, but does not provide the same RAD mechanisms. In fact, prooph\/micro is suitable for core domains (once stable), but requires more design decisions and work. I'll discuss this in detail in a future post."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-4","title":"Event Machine Roadmap","content":"Our plan was to finish documentation first and add some more tests before releasing Event Machine v1.0. Due to the prooph components announcement the plan changed. v1.0 will be released soon. Several projects already use Event Machine and a stable release will ensure that those projects don't run into trouble when we start refactoring of Event Machine. Work on documentation will be paused. In fact, the Event Machine tutorial is all you need to get started. API documentation will cover more details, but this has to wait."},{"id":"https:\/\/proophsoftware.github.io\/event-machine\/news\/2018-09-08-future.html#4-1-4-1","title":"Next Steps","content":" Remove prooph\/common Replace prooph\/event-sourcing Replace prooph\/service-bus Move Disco Light to separate package Move document store to separate package Move immutable record logic to separate package Use new prooph\/event-store-client and support async mode Implement non-blocking root projection as a persistent subscription "}]